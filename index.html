<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cripto AI - Top 100 Criptomoedas</title>
    <style> /* Reset e configurações básicas */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            /* Paleta de cores premium e moderna */
            --primary-color: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --secondary-color: #06b6d4;
            --secondary-light: #22d3ee;
            --accent-color: #f59e0b;
            --accent-light: #fbbf24;
            
            /* Cores de fundo com gradientes avançados */
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --bg-glass: rgba(255, 255, 255, 0.05);
            --bg-glass-hover: rgba(255, 255, 255, 0.1);
            
            /* Cores de texto refinadas */
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            
            /* Cores de status premium */
            --success-color: #10b981;
            --success-light: #34d399;
            --error-color: #ef4444;
            --error-light: #f87171;
            --warning-color: #f59e0b;
            --warning-light: #fbbf24;
            --info-color: #3b82f6;
            --info-light: #60a5fa;
            
            /* Sistema de sombras avançado */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            
            /* Sistema de bordas refinado */
            --border-radius-sm: 0.375rem;
            --border-radius-md: 0.5rem;
            --border-radius-lg: 0.75rem;
            --border-radius-xl: 1rem;
            --border-radius-2xl: 1.5rem;
            
            /* Sistema de transições */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-tertiary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(6, 182, 212, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(245, 158, 11, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        /* Header */
        .header {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: var(--shadow-xl);
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            opacity: 0.5;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 16px;
            position: relative;
        }
        
        .logo::before {
            content: '';
            position: absolute;
            top: -8px;
            left: -8px;
            right: -8px;
            bottom: -8px;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            border-radius: var(--border-radius-xl);
            opacity: 0.1;
            z-index: -1;
        }
        
        .logo i {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 4px 8px rgba(99, 102, 241, 0.3));
            animation: float 3s ease-in-out infinite;
        }
        
        .logo h1 {
            font-size: 2.25rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.025em;
        }
        
        .header-stats {
            display: flex;
            gap: 30px;
        }
        
        .stat-item {
            text-align: center;
            position: relative;
            padding: 16px 24px;
            background: var(--bg-glass);
            border-radius: var(--border-radius-xl);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: var(--transition-normal);
        }
        
        .stat-item:hover {
            background: var(--bg-glass-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .stat-label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* Status de conexão */
        .connection-status {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 2000;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        
        .connection-status.online {
            background: rgba(0, 212, 170, 0.2);
            color: var(--success-color);
            border: 1px solid rgba(0, 212, 170, 0.3);
        }
        
        .connection-status.offline {
            background: rgba(255, 107, 107, 0.2);
            color: var(--error-color);
            border: 1px solid rgba(255, 107, 107, 0.3);
        }
        
        .connection-status.cache {
            background: rgba(255, 165, 0, 0.2);
            color: var(--warning-color);
            border: 1px solid rgba(255, 165, 0, 0.3);
        }
        
        .connection-status.mock {
            background: rgba(160, 160, 160, 0.2);
            color: var(--text-secondary);
            border: 1px solid rgba(160, 160, 160, 0.3);
        }
        
        .connection-status i {
            font-size: 0.6rem;
        }
        
        /* Indicador de API */
        .api-indicator {
            position: fixed;
            top: 70px;
            left: 20px;
            z-index: 2000;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            background: rgba(99, 102, 241, 0.9);
            color: white;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .api-indicator.binance {
            background: rgba(240, 185, 11, 0.9);
            color: white;
        }
        
        .api-indicator.coinmarketcap {
            background: rgba(255, 107, 53, 0.9);
            color: white;
        }
        
        .api-indicator.cryptocompare {
            background: rgba(0, 188, 212, 0.9);
            color: white;
        }
        
        .api-indicator.coingecko {
            background: rgba(0, 212, 170, 0.9);
            color: white;
        }
        
        /* Main Content */
        .main {
            padding: 40px 0;
        }
        
        /* Controls */
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .search-box {
            position: relative;
            flex: 1;
            max-width: 400px;
        }
        
        .search-box i {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }
        
        .search-box input {
            width: 100%;
            padding: 16px 20px 16px 56px;
            border: none;
            border-radius: var(--border-radius-2xl);
            background: var(--bg-glass);
            color: var(--text-primary);
            font-size: 1rem;
            backdrop-filter: blur(10px);
            transition: var(--transition-normal);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: var(--shadow-md);
        }
        
        .search-box input:focus {
            outline: none;
            background: var(--bg-glass-hover);
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1), var(--shadow-lg);
            transform: translateY(-1px);
        }
        
        .search-box input::placeholder {
            color: var(--text-secondary);
        }
        
        .filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .filter-btn {
            padding: 12px 24px;
            border: none;
            border-radius: var(--border-radius-xl);
            background: var(--bg-glass);
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition-normal);
            backdrop-filter: blur(10px);
            font-size: 0.875rem;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: var(--shadow-md);
            position: relative;
            overflow: hidden;
        }
        
        .filter-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: var(--transition-normal);
        }
        
        .filter-btn:hover::before {
            left: 100%;
        }
        
        .filter-btn:hover {
            background: var(--bg-glass-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .filter-btn.active {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4);
            transform: translateY(-2px);
        }
        
        .swing-trade-btn {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-light));
            color: white;
            font-weight: 700;
        }
        
        .swing-trade-btn:hover {
            background: linear-gradient(135deg, #d97706, #f59e0b);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
        }
        
        .swing-trade-btn.active {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-light));
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
        }
        
        /* Crypto Table */
        .crypto-table-container {
            background: var(--bg-glass);
            border-radius: var(--border-radius-2xl);
            backdrop-filter: blur(20px);
            overflow: hidden;
            box-shadow: var(--shadow-2xl);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            margin: 20px 0;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) var(--bg-secondary);
        }
        
        /* Indicador de scroll horizontal para mobile */
        .scroll-hint {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            background: rgba(99, 102, 241, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            z-index: 10;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: slideInRight 0.5s ease;
            pointer-events: none;
        }
        
        /* Ocultar colunas desktop-only em mobile */
        .desktop-only {
            display: table-cell;
        }
        
        .scroll-hint.left {
            right: auto;
            left: 10px;
            animation: slideInLeft 0.5s ease;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateY(-50%) translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateY(-50%) translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideInLeft {
            from {
                transform: translateY(-50%) translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(-50%) translateX(0);
                opacity: 1;
            }
        }
        
        .crypto-table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .crypto-table-container::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-md);
        }
        
        .crypto-table-container::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: var(--border-radius-md);
        }
        
        .crypto-table-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, var(--primary-light), var(--secondary-light));
        }
        
        .crypto-table-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
        }
        
        .crypto-table-container::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--secondary-color), transparent);
            opacity: 0.3;
        }
        
        .crypto-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        
        .crypto-table th {
            background: rgba(30, 41, 59, 0.8);
            padding: 24px 20px;
            text-align: left;
            font-weight: 700;
            color: var(--text-primary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            position: relative;
        }
        
        /* Larguras específicas para colunas para garantir alinhamento */
        .crypto-table th:nth-child(1) { width: 8%; }  /* # */
        .crypto-table th:nth-child(2) { width: 25%; } /* Nome */
        .crypto-table th:nth-child(3) { width: 15%; } /* Preço */
        .crypto-table th:nth-child(4) { width: 12%; } /* 24h % */
        .crypto-table th:nth-child(5) { width: 12%; } /* 7d % */
        .crypto-table th:nth-child(6) { width: 15%; } /* Cap. de Mercado */
        .crypto-table th:nth-child(7) { width: 15%; } /* Volume (24h) */
        .crypto-table th:nth-child(8) { width: 15%; } /* Circulação */
        .crypto-table th:nth-child(9) { width: 15%; } /* Gráfico 7d */
        
        
        
        .crypto-table th::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            opacity: 0.5;
        }
        
        
        
        .crypto-table td {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: var(--transition-normal);
        }
        
        
        
        .crypto-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        
        
        .crypto-table tbody tr {
            cursor: pointer;
            transition: var(--transition-normal);
            position: relative;
            animation: fadeInUp 0.6s ease forwards;
            opacity: 0;
        }
        
        .crypto-table tbody tr::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: linear-gradient(180deg, var(--primary-color), var(--secondary-color));
            opacity: 0;
            transition: var(--transition-normal);
            border-radius: 0 2px 2px 0;
        }
        
        .crypto-table tbody tr:hover {
            background: var(--bg-glass-hover);
            transform: scale(1.005);
            box-shadow: var(--shadow-lg);
        }
        
        .crypto-table tbody tr:hover::before {
            opacity: 1;
        }
        
        
        
        /* Animações de entrada das linhas */
        .crypto-table tbody tr:nth-child(1) { animation-delay: 0.1s; }
        .crypto-table tbody tr:nth-child(2) { animation-delay: 0.2s; }
        .crypto-table tbody tr:nth-child(3) { animation-delay: 0.3s; }
        .crypto-table tbody tr:nth-child(4) { animation-delay: 0.4s; }
        .crypto-table tbody tr:nth-child(5) { animation-delay: 0.5s; }
        .crypto-table tbody tr:nth-child(6) { animation-delay: 0.6s; }
        .crypto-table tbody tr:nth-child(7) { animation-delay: 0.7s; }
        .crypto-table tbody tr:nth-child(8) { animation-delay: 0.8s; }
        .crypto-table tbody tr:nth-child(9) { animation-delay: 0.9s; }
        .crypto-table tbody tr:nth-child(10) { animation-delay: 1.0s; }
        
        .crypto-name {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        
        
        .crypto-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            box-shadow: var(--shadow-md);
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: var(--transition-normal);
        }
        
        .crypto-table tbody tr:hover .crypto-icon {
            transform: scale(1.1);
            border-color: var(--primary-color);
        }
        
        .crypto-info h3 {
            font-size: 1.125rem;
            font-weight: 700;
            margin-bottom: 4px;
            color: var(--text-primary);
            background: linear-gradient(135deg, var(--text-primary), var(--primary-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            transition: var(--transition-normal);
        }
        
        .crypto-table tbody tr:hover .crypto-info h3 {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .crypto-symbol {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 600;
            background: var(--bg-tertiary);
            padding: 4px 8px;
            border-radius: var(--border-radius-md);
            display: inline-block;
        }
        
        
        
        .price {
            font-weight: 700;
            font-size: 1.125rem;
            color: var(--text-primary);
            text-align: right;
        }
        
        
        
        .percentage {
            font-weight: 700;
            padding: 8px 16px;
            border-radius: var(--border-radius-xl);
            font-size: 0.875rem;
            display: inline-block;
            min-width: 80px;
            text-align: center;
            transition: var(--transition-normal);
        }
        
        
        
        .percentage.positive {
            background: rgba(16, 185, 129, 0.15);
            color: var(--success-light);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        
        .percentage.negative {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error-light);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        .percentage:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }
        
        .market-cap, .volume, .circulation {
            font-weight: 500;
            text-align: right;
        }
        
        .sparkline-chart {
            width: 120px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Swing Trade Score */
        .swing-trade-score {
            margin-top: 8px;
        }
        
        
        
        .score-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius-md);
            overflow: hidden;
            margin-bottom: 8px;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .score-bar::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: var(--border-radius-md);
            opacity: 0.3;
            z-index: -1;
        }
        
        .score-fill {
            height: 100%;
            border-radius: var(--border-radius-md);
            transition: width var(--transition-slow);
            position: relative;
            z-index: 1;
            overflow: hidden;
        }
        
        .score-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        .score-text {
            font-size: 0.875rem;
            font-weight: 700;
            text-align: center;
            display: block;
        }
        
        /* Cabeçalho de ordenação */
        .sorting-header {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(99, 102, 241, 0.1));
            border-radius: var(--border-radius-xl);
            margin: 16px 20px;
            border: 1px solid rgba(245, 158, 11, 0.2);
        }
        
        .sorting-header td {
            text-align: center;
            padding: 20px;
            background: transparent;
        }
        
        .sorting-header div {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            color: var(--accent-color);
            font-weight: 700;
            font-size: 1rem;
        }
        
        .sorting-header i {
            font-size: 1.25rem;
            animation: bounce 2s infinite;
        }
        
        /* Swing Trade Banner */
        .swing-trade-banner {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(99, 102, 241, 0.1) 100%);
            border-radius: var(--border-radius-2xl);
            padding: 32px;
            margin-bottom: 40px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(245, 158, 11, 0.2);
            box-shadow: var(--shadow-xl);
            position: relative;
            overflow: hidden;
        }
        
        .swing-trade-banner::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(245, 158, 11, 0.05) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }
        
        .banner-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
            position: relative;
            z-index: 1;
        }
        
        .banner-header i {
            font-size: 2rem;
            color: var(--accent-color);
            filter: drop-shadow(0 4px 8px rgba(245, 158, 11, 0.3));
        }
        
        .banner-header h3 {
            font-size: 1.75rem;
            color: var(--text-primary);
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-color), var(--primary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .banner-description {
            margin-bottom: 32px;
            position: relative;
            z-index: 1;
        }
        
        .banner-description p {
            margin-bottom: 20px;
            color: var(--text-secondary);
            font-size: 1.125rem;
            line-height: 1.7;
        }
        
        .banner-description ul {
            list-style: none;
            padding-left: 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
        }
        
        .banner-description li {
            margin-bottom: 0;
            padding: 16px 20px;
            background: var(--bg-glass);
            border-radius: var(--border-radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            position: relative;
            transition: var(--transition-normal);
        }
        
        .banner-description li:hover {
            background: var(--bg-glass-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .banner-description li:before {
            content: "🎯";
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.25rem;
        }
        
        .banner-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 24px;
            position: relative;
            z-index: 1;
        }
        
        .stat {
            text-align: center;
            padding: 24px;
            background: var(--bg-glass);
            border-radius: var(--border-radius-xl);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: var(--transition-normal);
            position: relative;
            overflow: hidden;
        }
        
        .stat::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
        }
        
        .stat:hover {
            background: var(--bg-glass-hover);
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
        }
        
        .stat-number {
            display: block;
            font-size: 2rem;
            font-weight: 800;
            color: var(--primary-color);
            margin-bottom: 8px;
            text-shadow: 0 4px 8px rgba(99, 102, 241, 0.3);
        }
        
        .stat-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        /* Loading e Error States */
        .loading, .error {
            text-align: center;
            padding: 60px 20px;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-5px); }
            60% { transform: translateY(-3px); }
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .loading p, .error p {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }
        
        .error i {
            font-size: 3rem;
            color: var(--error-color);
            margin-bottom: 20px;
        }
        
        .error button {
            padding: 12px 25px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .error button:hover {
            background: #00b894;
            transform: translateY(-2px);
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 3000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: var(--bg-secondary);
            margin: 3% auto;
            padding: 0;
            border-radius: var(--border-radius-2xl);
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-2xl);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            animation: fadeInUp 0.5s ease;
        }
        
        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: var(--border-radius-2xl) var(--border-radius-2xl) 0 0;
        }
        
        .modal-content::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--secondary-color), var(--primary-color));
            border-radius: 0 0 var(--border-radius-2xl) var(--border-radius-2xl);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 32px 40px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(30, 41, 59, 0.5);
        }
        
        .modal-header h2 {
            font-size: 2rem;
            color: var(--text-primary);
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .close-btn {
            background: var(--bg-glass);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 12px;
            border-radius: 50%;
            transition: var(--transition-normal);
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-btn:hover {
            background: var(--bg-glass-hover);
            color: var(--text-primary);
            transform: rotate(90deg);
        }
        
        .modal-body {
            padding: 40px;
        }
        
        .crypto-details {
            color: var(--text-primary);
        }
        
        .crypto-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .crypto-basic-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .crypto-price-info h2 {
            color: var(--primary-color);
            margin-bottom: 15px;
        }
        
        .crypto-stats {
            margin-top: 30px;
        }
        
        .stat-card {
            background: var(--bg-glass);
            padding: 24px;
            border-radius: var(--border-radius-xl);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: var(--transition-normal);
        }
        
        .stat-card:hover {
            background: var(--bg-glass-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .stat-card h4 {
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        
        .stat-card p {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .crypto-chart {
            margin-top: 30px;
        }
        
        .crypto-chart h4 {
            color: var(--text-secondary);
            margin-bottom: 15px;
        }
        
        /* Mensagens de Aviso */
        .warning-message {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 3000;
            animation: slideInRight 0.3s ease;
        }
        
        .warning-content {
            background: rgba(255, 165, 0, 0.2);
            color: var(--warning-color);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 165, 0, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Footer */
        .footer {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 40px 0;
            text-align: center;
            margin-top: 80px;
            position: relative;
        }
        
        .footer::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
        }
        
        .footer p {
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 500;
            position: relative;
            display: inline-block;
        }
        
        .footer p::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            transition: var(--transition-normal);
        }
        
        .footer:hover p::after {
            width: 100%;
        }
        
        /* ===== ANIMAÇÕES DE PREÇO EM TEMPO REAL ===== */
        
        .price-updating {
            transition: all 0.3s ease;
        }
        
        .price-up {
            animation: priceUp 2s ease-out;
            background: rgba(0, 212, 170, 0.1);
            border-radius: 4px;
            padding: 2px 6px;
        }
        
        .price-down {
            animation: priceDown 2s ease-out;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 4px;
            padding: 2px 6px;
        }
        
        @keyframes priceUp {
            0% {
                background: rgba(0, 212, 170, 0.3);
                transform: scale(1.05);
            }
            50% {
                background: rgba(0, 212, 170, 0.2);
                transform: scale(1.02);
            }
            100% {
                background: rgba(0, 212, 170, 0.1);
                transform: scale(1);
            }
        }
        
        @keyframes priceDown {
            0% {
                background: rgba(255, 107, 107, 0.3);
                transform: scale(1.05);
            }
            50% {
                background: rgba(255, 107, 107, 0.2);
                transform: scale(1.02);
            }
            100% {
                background: rgba(255, 107, 107, 0.1);
                transform: scale(1);
            }
        }
        
        /* Controles de Tempo Real */
        .real-time-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-primary);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        .control-btn i {
            font-size: 0.9rem;
        }
        
        /* Indicador de atualização em tempo real */
        .real-time-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1500;
            background: rgba(0, 212, 170, 0.2);
            color: var(--success-color);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 212, 170, 0.3);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }
        
        /* Responsividade */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }
            
            .header-stats {
                gap: 20px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-box {
                max-width: none;
            }
            
            .filters {
                justify-content: center;
            }
            
                    /* ===== NOVO LAYOUT MOBILE EM LISTA VERTICAL ===== */
        
        /* Layout mobile completamente reorganizado para lista vertical */
        @media (max-width: 768px) {
            /* Ocultar elementos desktop */
            .crypto-table-container {
                display: none !important;
            }
            
            /* Mostrar lista mobile */
            .crypto-list-mobile {
                display: block !important;
            }
            
            .header-content {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }
            .header-content {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }
            
            .header-stats {
                gap: 20px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-box {
                max-width: none;
            }
            
            .filters {
                justify-content: center;
            }
            
            /* ===== NOVO LAYOUT MOBILE EM LISTA VERTICAL ===== */
            
            /* Ocultar tabela desktop em mobile */
            .crypto-table-container {
                display: none !important;
            }
            
            /* Mostrar lista mobile */
            .crypto-list-mobile {
                display: block !important;
            }
            
            /* Container da lista mobile */
            .crypto-list-mobile {
                display: none;
                background: var(--bg-glass);
                border-radius: var(--border-radius-2xl);
                backdrop-filter: blur(20px);
                overflow: hidden;
                box-shadow: var(--shadow-2xl);
                border: 1px solid rgba(255, 255, 255, 0.1);
                margin: 20px 0;
            }
            
            /* Cabeçalho da lista mobile */
            .mobile-list-header {
                display: flex;
                background: rgba(30, 41, 59, 0.8);
                padding: 20px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                font-weight: 700;
                color: var(--text-primary);
                font-size: 0.875rem;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }
            
            .mobile-list-header .col-name {
                flex: 2;
            }
            
            .mobile-list-header .col-24h {
                flex: 1;
                text-align: center;
            }
            
            .mobile-list-header .col-7d {
                flex: 1;
                text-align: center;
            }
            
            /* Card individual de criptomoeda */
            .crypto-card {
                display: flex;
                align-items: center;
                padding: 20px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                transition: var(--transition-normal);
                cursor: pointer;
                position: relative;
                background: transparent;
            }
            
            .crypto-card:last-child {
                border-bottom: none;
            }
            
            .crypto-card:hover {
                background: var(--bg-glass-hover);
                transform: translateY(-2px);
                box-shadow: var(--shadow-lg);
            }
            
            .crypto-card::before {
                content: '';
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                width: 4px;
                background: linear-gradient(180deg, var(--primary-color), var(--secondary-color));
                opacity: 0;
                transition: var(--transition-normal);
                border-radius: 0 2px 2px 0;
            }
            
            .crypto-card:hover::before {
                opacity: 1;
            }
            
            /* Coluna do nome (flex: 2) */
            .crypto-card .col-name {
                flex: 2;
                display: flex;
                align-items: center;
                gap: 15px;
            }
            
            /* Ícone de estrela para favoritos */
            .favorite-star {
                color: var(--text-muted);
                font-size: 1.2rem;
                cursor: pointer;
                transition: var(--transition-normal);
                margin-right: 10px;
            }
            
            .favorite-star:hover {
                color: var(--accent-color);
                transform: scale(1.1);
            }
            
            .favorite-star.active {
                color: var(--accent-color);
            }
            
            /* Informações da criptomoeda */
            .crypto-info-mobile h3 {
                font-size: 1.125rem;
                font-weight: 700;
                margin-bottom: 4px;
                color: var(--text-primary);
                background: linear-gradient(135deg, var(--text-primary), var(--primary-light));
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
            }
            
            .crypto-symbol-mobile {
                font-size: 0.875rem;
                color: var(--text-secondary);
                font-weight: 600;
                background: var(--bg-tertiary);
                padding: 4px 8px;
                border-radius: var(--border-radius-md);
                display: inline-block;
            }
            
            /* Botão Buy */
            .buy-btn {
                background: linear-gradient(135deg, var(--primary-color), var(--primary-light));
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: var(--border-radius-xl);
                font-size: 0.875rem;
                font-weight: 600;
                cursor: pointer;
                transition: var(--transition-normal);
                margin-left: 15px;
                box-shadow: var(--shadow-md);
            }
            
            .buy-btn:hover {
                background: linear-gradient(135deg, var(--primary-dark), var(--primary-color));
                transform: translateY(-2px);
                box-shadow: var(--shadow-lg);
            }
            
            /* Colunas de porcentagem (flex: 1 cada) */
            .crypto-card .col-24h,
            .crypto-card .col-7d {
                flex: 1;
                text-align: center;
            }
            
            /* Porcentagens com design melhorado */
            .percentage-mobile {
                font-weight: 700;
                padding: 8px 12px;
                border-radius: var(--border-radius-xl);
                font-size: 0.875rem;
                display: inline-block;
                min-width: 70px;
                text-align: center;
                transition: var(--transition-normal);
            }
            
            .percentage-mobile.positive {
                background: rgba(16, 185, 129, 0.15);
                color: var(--success-light);
                border: 1px solid rgba(16, 185, 129, 0.3);
            }
            
            .percentage-mobile.negative {
                background: rgba(239, 68, 68, 0.15);
                color: var(--error-light);
                border: 1px solid rgba(239, 68, 68, 0.3);
            }
            
            .percentage-mobile:hover {
                transform: scale(1.05);
                box-shadow: var(--shadow-md);
            }
            
            /* Score de swing trade para mobile */
            .swing-trade-score-mobile {
                margin-top: 8px;
            }
            
            .score-bar-mobile {
                width: 100%;
                height: 6px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: var(--border-radius-md);
                overflow: hidden;
                margin-bottom: 6px;
                position: relative;
                box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            }
            
            .score-fill-mobile {
                height: 100%;
                border-radius: var(--border-radius-md);
                transition: width var(--transition-slow);
                position: relative;
                z-index: 1;
            }
            
            .score-text-mobile {
                font-size: 0.8rem;
                font-weight: 600;
                text-align: center;
                display: block;
            }
            
            /* Animações para mobile */
            .crypto-card {
                animation: fadeInUp 0.4s ease forwards;
                opacity: 0;
                transform: translateY(15px);
            }
            
            .crypto-card:nth-child(1) { animation-delay: 0.1s; }
            .crypto-card:nth-child(2) { animation-delay: 0.2s; }
            .crypto-card:nth-child(3) { animation-delay: 0.3s; }
            .crypto-card:nth-child(4) { animation-delay: 0.4s; }
            .crypto-card:nth-child(5) { animation-delay: 0.5s; }
            
            @keyframes fadeInUp {
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            
            /* Melhorias nos controles para mobile */
            .filter-btn {
                padding: 12px 18px;
                font-size: 0.85rem;
                min-width: 90px;
            }
            
            .swing-trade-btn {
                min-width: 130px;
            }
            
            /* Otimizações para header mobile */
            .logo h1 {
                font-size: 1.8rem;
            }
            
            .logo i {
                font-size: 2rem;
            }
            
            .stat-item {
                padding: 12px 16px;
            }
            
            .stat-value {
                font-size: 1.2rem;
            }
            
            .stat-label {
                font-size: 0.7rem;
            }
            
            /* Melhorias específicas para dispositivos móveis */
            .connection-status {
                top: 10px;
                left: 10px;
                right: 10px;
                text-align: center;
                font-size: 0.75rem;
                position: fixed;
                z-index: 2000;
            }
            
            .real-time-indicator {
                top: 60px;
                right: 10px;
                left: 10px;
                text-align: center;
                font-size: 0.75rem;
            }
        }
            
            /* Ocultar colunas desktop-only em mobile */
            .desktop-only {
                display: none !important;
            }
            
            /* Larguras específicas para mobile (3 colunas) */
            .crypto-table th:nth-child(1) { width: 25%; }  /* Nome */
            .crypto-table th:nth-child(2) { width: 37.5%; }  /* 24h % */
            .crypto-table th:nth-child(3) { width: 37.5%; }  /* 7d % */
            
            .crypto-table-container::-webkit-scrollbar {
                height: 8px;
            }
            
            .crypto-table-container::-webkit-scrollbar-track {
                background: var(--bg-secondary);
                border-radius: var(--border-radius-md);
            }
            
            .crypto-table-container::-webkit-scrollbar-thumb {
                background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
                border-radius: var(--border-radius-md);
            }
            
            .crypto-table {
                min-width: 700px; /* Largura mínima para 3 colunas mobile */
                table-layout: fixed; /* Layout fixo para melhor performance */
                border-collapse: separate;
                border-spacing: 0;
            }
            
            /* Melhorar legibilidade das linhas no mobile */
            .crypto-table tbody tr {
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                transition: var(--transition-normal);
            }
            
            .crypto-table tbody tr:hover {
                background: var(--bg-glass-hover);
                transform: scale(1.005);
            }
            
            /* Otimizar células para mobile */
            .crypto-table th,
            .crypto-table td {
                padding: 16px 16px;
                font-size: 0.85rem;
                vertical-align: middle;
                white-space: nowrap; /* Evitar quebra de linha */
            }
            
            /* Melhorar exibição do nome da cripto no mobile */
            .crypto-name {
                min-width: 160px;
                gap: 12px;
            }
            
            .crypto-icon {
                width: 40px;
                height: 40px;
                border: 2px solid rgba(255, 255, 255, 0.2);
                flex-shrink: 0; /* Evitar que a imagem encolha */
            }
            
            .crypto-info h3 {
                font-size: 1rem;
                font-weight: 700;
                margin-bottom: 4px;
                line-height: 1.2;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .crypto-symbol {
                font-size: 0.8rem;
                padding: 4px 8px;
                white-space: nowrap;
            }
            
            /* Otimizar preços para mobile */
            .price {
                font-size: 1.1rem;
                font-weight: 700;
                color: var(--text-primary);
                text-align: right;
                white-space: nowrap;
            }
            
            /* Melhorar porcentagens para mobile */
            .percentage {
                padding: 8px 12px;
                min-width: 70px;
                font-size: 0.85rem;
                font-weight: 600;
                white-space: nowrap;
                text-align: center;
                display: inline-block;
            }
            
            /* Melhorar alinhamento das colunas mobile */
            .crypto-table th:nth-child(2),
            .crypto-table th:nth-child(3) {
                text-align: center;
            }
            
            .crypto-table td:nth-child(2),
            .crypto-table td:nth-child(3) {
                text-align: center;
            }
            
            /* Otimizar estatísticas para mobile */
            .market-cap, .volume, .circulation {
                font-size: 0.85rem;
                font-weight: 500;
                color: var(--text-secondary);
                text-align: right;
                white-space: nowrap;
            }
            
            /* Melhorar gráfico sparkline no mobile */
            .sparkline-chart {
                width: 100px;
                height: 35px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: var(--border-radius-md);
                background: rgba(255, 255, 255, 0.02);
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Score de swing trade otimizado para mobile */
            .swing-trade-score {
                margin-top: 8px;
            }
            
            .score-bar {
                width: 100%;
                height: 6px;
                margin-bottom: 6px;
            }
            
            .score-text {
                font-size: 0.8rem;
                font-weight: 600;
            }
            
            /* Animações suaves para mobile */
            .crypto-table tbody tr {
                animation: fadeInUp 0.4s ease forwards;
                opacity: 0;
                transform: translateY(15px);
            }
            
            .crypto-table tbody tr:nth-child(1) { animation-delay: 0.1s; }
            .crypto-table tbody tr:nth-child(2) { animation-delay: 0.2s; }
            .crypto-table tbody tr:nth-child(3) { animation-delay: 0.3s; }
            .crypto-table tbody tr:nth-child(4) { animation-delay: 0.4s; }
            .crypto-table tbody tr:nth-child(5) { animation-delay: 0.5s; }
            
            @keyframes fadeInUp {
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            
            /* Melhorias nos controles para mobile */
            .filter-btn {
                padding: 12px 18px;
                font-size: 0.85rem;
                min-width: 90px;
            }
            
            .swing-trade-btn {
                min-width: 130px;
            }
            
            /* Otimizações para header mobile */
            .logo h1 {
                font-size: 1.8rem;
            }
            
            .logo i {
                font-size: 2rem;
            }
            
            .stat-item {
                padding: 12px 16px;
            }
            
            .stat-value {
                font-size: 1.2rem;
            }
            
            .stat-label {
                font-size: 0.7rem;
            }
            
            /* Melhorias específicas para dispositivos móveis */
            .connection-status {
                top: 10px;
                left: 10px;
                right: 10px;
                text-align: center;
                font-size: 0.75rem;
                position: fixed;
                z-index: 2000;
            }
            
            .real-time-indicator {
                top: 60px;
                right: 10px;
                left: 10px;
                text-align: center;
                font-size: 0.75rem;
            }
            

        }
        
        @media (max-width: 480px) {
            .container {
                padding: 0 15px;
            }
            
            .logo h1 {
                font-size: 1.5rem;
            }
            
            .filters {
                gap: 8px;
            }
            
            .filter-btn {
                padding: 8px 15px;
                font-size: 0.8rem;
            }
            
            /* Otimizações para lista mobile em telas muito pequenas */
            .crypto-card {
                padding: 16px;
            }
            
            .crypto-info-mobile h3 {
                font-size: 1rem;
            }
            
            .crypto-symbol-mobile {
                font-size: 0.8rem;
                padding: 3px 6px;
            }
            
            .buy-btn {
                padding: 6px 12px;
                font-size: 0.8rem;
                margin-left: 10px;
            }
            
            .percentage-mobile {
                padding: 6px 10px;
                min-width: 60px;
                font-size: 0.8rem;
            }
            
            .score-bar-mobile {
                height: 5px;
                margin-bottom: 4px;
            }
            
            .score-text-mobile {
                font-size: 0.7rem;
            }
        }
        </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <i class="fas fa-brain"></i>
                    <h1>Cripto AI</h1>
                </div>
                <div class="header-stats">
                    <div class="stat-item">
                        <span class="stat-label">Cap. Total</span>
                        <span class="stat-value" id="total-market-cap">$0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Volume 24h</span>
                        <span class="stat-value" id="total-volume">$0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Dominância BTC</span>
                        <span class="stat-value" id="btc-dominance">0%</span>
                    </div>
                </div>
            </div>
        </div>
    </header>
    
    <!-- Indicador de Atualização em Tempo Real -->
    <div class="real-time-indicator" id="real-time-indicator" style="display: none;">
        <i class="fas fa-sync-alt fa-spin"></i>
        <span>Atualização em Tempo Real</span>
    </div>

    <!-- Main Content -->
    <main class="main">
        <div class="container">
            <!-- Search and Filters -->
            <div class="controls">
                <div class="search-box">
                    <i class="fas fa-search"></i>
                    <input type="text" id="search-input" placeholder="Buscar criptomoeda...">
                </div>
                <div class="filters">
                    <button class="filter-btn active" data-filter="all">Todas</button>
                    <button class="filter-btn" data-filter="gainers">Ganhadores</button>
                    <button class="filter-btn" data-filter="losers">Perdedores</button>
                    <button class="filter-btn swing-trade-btn" data-filter="swing-trade">
                        <i class="fas fa-chart-line"></i>
                        Swing Trade
                    </button>
                    
                    <!-- Controles de Tempo Real -->
                    <div class="real-time-controls">
                        <button class="control-btn" id="pause-realtime" title="Pausar atualizações em tempo real">
                            <i class="fas fa-pause"></i>
                        </button>
                        <button class="control-btn" id="resume-realtime" title="Retomar atualizações em tempo real" style="display: none;">
                            <i class="fas fa-play"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Crypto Table (Desktop) -->
            <div class="crypto-table-container">
                <table class="crypto-table">
                    <thead>
                        <tr>
                            <th class="desktop-only">#</th>
                            <th>Nome</th>
                            <th class="desktop-only">Preço</th>
                            <th>24h %</th>
                            <th>7d %</th>
                            <th class="desktop-only">Cap. de Mercado</th>
                            <th class="desktop-only">Volume (24h)</th>
                            <th class="desktop-only">Circulação</th>
                            <th class="desktop-only">Gráfico 7d</th>
                        </tr>
                    </thead>
                    <tbody id="crypto-table-body">
                        <!-- Dados serão inseridos aqui via JavaScript -->
                    </tbody>
                </table>
            </div>

            <!-- Crypto List Mobile -->
            <div class="crypto-list-mobile" id="crypto-list-mobile">
                <div class="mobile-list-header">
                    <div class="col-name">Nome</div>
                    <div class="col-24h">24h %</div>
                    <div class="col-7d">7d %</div>
                </div>
                <div id="crypto-list-body">
                    <!-- Dados mobile serão inseridos aqui via JavaScript -->
                </div>
            </div>



            <!-- Loading State -->
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Carregando dados das criptomoedas...</p>
            </div>

            <!-- Error State -->
            <div class="error" id="error" style="display: none;">
                <i class="fas fa-exclamation-triangle"></i>
                <p>Erro ao carregar dados. Tente novamente.</p>
                <button onclick="loadCryptoData()">Tentar Novamente</button>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>&copy; 2024 Cripto AI. Dados fornecidos por <span id="footer-api">CoinGecko API</span>.</p>
        </div>
    </footer>

    <!-- Crypto Details Modal -->
    <div class="modal" id="crypto-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Detalhes da Criptomoeda</h2>
                <button class="close-btn" onclick="closeModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body" id="modal-body">
                <!-- Conteúdo do modal será inserido aqui -->
            </div>
        </div>
    </div>

    <script >// Configurações da API
        const COINGECKO_API_BASE = 'https://api.coingecko.com/api/v3';
        const BINANCE_API_BASE = 'https://api.binance.com/api/v3';
        const COINMARKETCAP_API_BASE = 'https://pro-api.coinmarketcap.com/v1';
        const COINMARKETCAP_API_KEY = 'demo'; // Usando chave demo para testes
        
        // Nova API mais robusta para iPhone - CryptoCompare
        const CRYPTOCOMPARE_API_BASE = 'https://min-api.cryptocompare.com/data';
        const UPDATE_INTERVAL = 30000; // 30 segundos para desktop/WiFi
        const MOBILE_UPDATE_INTERVAL = 300000; // 5 minutos para dados móveis
        const REAL_TIME_UPDATE_INTERVAL = 10000; // 10 segundos para atualizações em tempo real
        const CACHE_DURATION = 300000; // 5 minutos de cache
        
        // Configurações específicas para dados móveis
        const MOBILE_TIMEOUT = 15000; // 15 segundos para dados móveis (mais agressivo)
        const DESKTOP_TIMEOUT = 30000; // 30 segundos para desktop
        const MAX_RETRIES = 3; // Máximo de tentativas
        const RETRY_DELAYS = [1000, 2000, 4000]; // Delays para retry (backoff exponencial)
        
        // Estado global da aplicação
        let cryptoData = [];
        let filteredData = [];
        let currentFilter = 'all';
        let searchTerm = '';
        let lastUpdate = 0;
        let isUpdating = false;
        let previousPrices = new Map(); // Armazena preços anteriores para comparação
        let realTimeUpdateInterval = null; // Intervalo para atualizações em tempo real
        let retryCount = 0; // Contador de tentativas
        let isMobileData = false; // Flag para detectar se está usando dados móveis
        
        // Configuração de atualizações em tempo real para mobile
        const MOBILE_REAL_TIME_INTERVAL = 15000; // 15 segundos para mobile (mais frequente)
        const DESKTOP_REAL_TIME_INTERVAL = 10000; // 10 segundos para desktop
        
        // Detectar se é dispositivo móvel
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Elementos DOM
        const cryptoTableBody = document.getElementById('crypto-table-body');
        const searchInput = document.getElementById('search-input');
        const loadingElement = document.getElementById('loading');
        const errorElement = document.getElementById('error');
        const totalMarketCap = document.getElementById('total-market-cap');
        const totalVolume = document.getElementById('total-volume');
        const btcDominance = document.getElementById('btc-dominance');

        const realTimeIndicator = document.getElementById('real-time-indicator');
        
        // Função para verificar se o navegador suporta fetch
        function supportsFetch() {
            return typeof fetch !== 'undefined';
        }
        
        // Função para verificar se o navegador suporta localStorage
        function supportsLocalStorage() {
            try {
                const test = 'test';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // Função para fazer requisição HTTP com fallback e retry
        async function makeRequest(url, options = {}, retryAttempt = 0) {
            const timeout = isMobileData ? MOBILE_TIMEOUT : DESKTOP_TIMEOUT;
            
            if (supportsFetch()) {
                try {
                    // Remover User-Agent personalizado para melhor compatibilidade
                    const cleanOptions = { ...options };
                    if (cleanOptions.headers) {
                        delete cleanOptions.headers['User-Agent'];
                    }
                    
                    // Criar AbortController para timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);
                    
                    const response = await fetch(url, {
                        ...cleanOptions,
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    return response;
                } catch (error) {
                    console.warn(`Fetch falhou (tentativa ${retryAttempt + 1}):`, error);
                    
                    // Retry automático para erros de rede
                    if (retryAttempt < MAX_RETRIES && (error.name === 'AbortError' || error.message.includes('fetch'))) {
                        const delay = RETRY_DELAYS[retryAttempt] || 1000;
                        console.log(`Tentando novamente em ${delay}ms...`);
                        
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return makeRequest(url, options, retryAttempt + 1);
                    }
                    
                    return makeXHRRequest(url, options);
                }
            } else {
                return makeXHRRequest(url, options);
            }
        }
        
        // Fallback para XMLHttpRequest
        function makeXHRRequest(url, options = {}) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                
                xhr.open(options.method || 'GET', url, true);
                
                if (options.headers) {
                    Object.keys(options.headers).forEach(key => {
                        if (key !== 'User-Agent') { // Não enviar User-Agent personalizado
                            xhr.setRequestHeader(key, options.headers[key]);
                        }
                    });
                }
                
                xhr.onload = function() {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        resolve({
                            ok: true,
                            status: xhr.status,
                            json: () => Promise.resolve(JSON.parse(xhr.responseText))
                        });
                    } else {
                        reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
                    }
                };
                
                xhr.onerror = function() {
                    reject(new Error('Erro de rede'));
                };
                
                xhr.ontimeout = function() {
                    reject(new Error('Timeout da requisição'));
                };
                
                // Timeout específico para dados móveis
                const timeout = isMobileData ? MOBILE_TIMEOUT : DESKTOP_TIMEOUT;
                xhr.timeout = timeout;
                xhr.send(options.body);
            });
        }
        
        // Função para atualizar status de conexão

        

        
        // Função para mostrar aviso
        function showWarning(message) {
            // Criar aviso temporário
            const warning = document.createElement('div');
            warning.className = 'warning-message';
            warning.innerHTML = `
                <div class="warning-content">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span>${message}</span>
                </div>
            `;
            
            document.body.appendChild(warning);
            
            // Remover após 5 segundos
            setTimeout(() => {
                if (warning.parentNode) {
                    warning.parentNode.removeChild(warning);
                }
            }, 5000);
        }
        
        // Inicialização da aplicação
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });
        
        function initializeApp() {
            // Configurar exibição mobile/desktop
            setupMobileDesktopDisplay();
            
            // Adicionar indicador de scroll horizontal para mobile
            if (isMobile) {
                addScrollIndicator();
            }
            
            // Tentar carregar dados do cache primeiro
            if (loadFromCache()) {
                displayCryptoData();
                setupEventListeners();
                setupAutoUpdate();
                loadFavorites(); // Carregar favoritos salvos
            } else {
                loadCryptoData();
                setupEventListeners();
                setupAutoUpdate();
                loadFavorites(); // Carregar favoritos salvos
            }
        }
        
        // Função para configurar exibição mobile/desktop
        function setupMobileDesktopDisplay() {
            const tableContainer = document.querySelector('.crypto-table-container');
            const listContainer = document.querySelector('.crypto-list-mobile');
            
            if (isMobile) {
                // Em mobile, mostrar lista e ocultar tabela
                if (tableContainer) tableContainer.style.display = 'none';
                if (listContainer) listContainer.style.display = 'block';
            } else {
                // Em desktop, mostrar tabela e ocultar lista
                if (tableContainer) tableContainer.style.display = 'block';
                if (listContainer) listContainer.style.display = 'none';
            }
        }
        
        function setupEventListeners() {
            // Busca
            searchInput.addEventListener('input', function(e) {
                searchTerm = e.target.value.toLowerCase();
                filterAndDisplayData();
            });
        
            // Filtros
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentFilter = this.dataset.filter;
                    filterAndDisplayData();
                });
            });
        
            // Fechar modal ao clicar fora
            window.addEventListener('click', function(e) {
                const modal = document.getElementById('crypto-modal');
                if (e.target === modal) {
                    closeModal();
                }
            });
            
            // Controles de tempo real
            const pauseBtn = document.getElementById('pause-realtime');
            const resumeBtn = document.getElementById('resume-realtime');
            
            if (pauseBtn) {
                pauseBtn.addEventListener('click', function() {
                    stopRealTimeUpdates();
                    pauseBtn.style.display = 'none';
                    resumeBtn.style.display = 'flex';
                });
            }
            
            if (resumeBtn) {
                resumeBtn.addEventListener('click', function() {
                    resumeRealTimeUpdates();
                    resumeBtn.style.display = 'none';
                    pauseBtn.style.display = 'flex';
                });
            }
            
            // Listeners para mudanças de conectividade (especialmente importante para dispositivos móveis)
            window.addEventListener('online', function() {
                console.log('Conexão restaurada');
                showWarning('✅ Conexão restaurada! Tentando carregar dados atualizados...');
                
                // Tentar carregar dados novamente após alguns segundos
                setTimeout(() => {
                    if (cryptoData.length === 0) {
                        loadCryptoData();
                    }
                }, 2000);
            });
            
            window.addEventListener('offline', function() {
                console.log('Conexão perdida');
                showWarning('❌ Conexão perdida. Dados podem estar desatualizados.');
            });
            
            // Listener para mudanças na qualidade da conexão (dispositivos móveis)
            if ('connection' in navigator) {
                navigator.connection.addEventListener('change', function() {
                    const connection = navigator.connection;
                    console.log('📱 Qualidade da conexão mudou:', connection.effectiveType);
                    
                    // Detectar se mudou para dados móveis
                    if (connection.type === 'cellular') {
                        isMobileData = true;
                        console.log('📱 Mudou para dados móveis');
                        showWarning('📱 Conexão móvel detectada - otimizando para melhor performance');

                    }
                    
                    // Monitorar qualidade da conexão em tempo real
                    console.log('📊 Nova qualidade da conexão:', {
                        effectiveType: connection.effectiveType,
                        rtt: connection.rtt,
                        downlink: connection.downlink,
                        saveData: connection.saveData
                    });
                    
                    // Ajustar configurações baseado na nova qualidade
                    if (connection.effectiveType === 'slow-2g' || connection.rtt > 300) {
                        console.log('🚨 Conexão crítica detectada! Ajustando para modo de emergência...');
                        showWarning('🚨 Conexão muito lenta! Ajustando para modo de emergência...');
                        MOBILE_UPDATE_INTERVAL = 15 * 60 * 1000; // 15 minutos para conexões críticas
                    } else if (connection.effectiveType === '2g' || connection.rtt > 200) {
                        console.log('🐌 Conexão lenta detectada. Ajustando configurações...');
                        showWarning('🐌 Conexão lenta detectada. Ajustando para melhor performance...');
                        MOBILE_UPDATE_INTERVAL = 10 * 60 * 1000; // 10 minutos para conexões lentas
                    }
                    
                    if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
                        showWarning('🐌 Conexão lenta detectada. Considere usar Wi-Fi para melhor performance.');
                    }
                    
                    // Se a conexão melhorou, tentar carregar dados novamente
                    if (connection.effectiveType === '4g' && cryptoData.length === 0) {
                        setTimeout(() => {
                            showWarning('🚀 Conexão melhorou! Tentando carregar dados...');
                            loadCryptoData();
                        }, 2000);
                    }
                });
            }
            
            // Listener para mudanças de tamanho de tela (responsive)
            window.addEventListener('resize', function() {
                const newIsMobile = window.innerWidth <= 768;
                if (newIsMobile !== isMobile) {
                    isMobile = newIsMobile;
                    setupMobileDesktopDisplay();
                    console.log('📱 Tamanho de tela mudou, ajustando layout para:', isMobile ? 'Mobile' : 'Desktop');
                }
            });
        }
        
        // Sistema de Cache Local
        function saveToCache(data) {
            try {
                if (!supportsLocalStorage()) {
                    console.warn('localStorage não suportado, usando cache em memória');
                    // Fallback: cache em memória (será perdido ao recarregar a página)
                    window.memoryCache = {
                        data: data,
                        timestamp: Date.now()
                    };
                    lastUpdate = Date.now();
                    return;
                }
                
                const cacheData = {
                    data: data,
                    timestamp: Date.now()
                };
                localStorage.setItem('cryptoCache', JSON.stringify(cacheData));
                lastUpdate = Date.now();
            } catch (error) {
                console.warn('Erro ao salvar cache:', error);
                // Fallback para cache em memória
                window.memoryCache = {
                    data: data,
                    timestamp: Date.now()
                };
                lastUpdate = Date.now();
            }
        }
        
        function loadFromCache() {
            try {
                // Tentar localStorage primeiro
                if (supportsLocalStorage()) {
                    const cached = localStorage.getItem('cryptoCache');
                    if (cached) {
                        const cacheData = JSON.parse(cached);
                        const now = Date.now();
                        
                        // Verificar se o cache ainda é válido (5 minutos)
                        if (now - cacheData.timestamp < CACHE_DURATION) {
                            cryptoData = cacheData.data;
                            filteredData = [...cryptoData];
                            lastUpdate = cacheData.timestamp;
                            console.log('Dados carregados do localStorage cache');

                            return true;
                        }
                    }
                }
                
                // Fallback para cache em memória
                if (window.memoryCache) {
                    const now = Date.now();
                    if (now - window.memoryCache.timestamp < CACHE_DURATION) {
                        cryptoData = window.memoryCache.data;
                        filteredData = [...cryptoData];
                        lastUpdate = window.memoryCache.timestamp;
                        console.log('Dados carregados do cache em memória');

                        return true;
                    }
                }
            } catch (error) {
                console.warn('Erro ao carregar cache:', error);
            }
            return false;
        }
        
        // Sistema de Fallback com dados mock
        function loadMockData() {
            console.log('Carregando dados mock para demonstração...');
            
            const mockData = [
                {
                    id: 'bitcoin',
                    name: 'Bitcoin',
                    symbol: 'btc',
                    image: 'https://assets.coingecko.com/coins/images/1/large/bitcoin.png',
                    current_price: 45000,
                    market_cap: 850000000000,
                    market_cap_rank: 1,
                    total_volume: 25000000000,
                    circulating_supply: 19500000,
                    price_change_percentage_24h: 2.5,
                    price_change_percentage_7d_in_currency: 8.3,
                    sparkline_in_7d: { price: [42000, 43000, 44000, 43500, 45000, 44800, 45000] }
                },
                {
                    id: 'ethereum',
                    name: 'Ethereum',
                    symbol: 'eth',
                    image: 'https://assets.coingecko.com/coins/images/279/large/ethereum.png',
                    current_price: 3200,
                    market_cap: 380000000000,
                    market_cap_rank: 2,
                    total_volume: 18000000000,
                    circulating_supply: 120000000,
                    price_change_percentage_24h: 3.2,
                    price_change_percentage_7d_in_currency: 12.1,
                    sparkline_in_7d: { price: [2850, 2900, 3000, 3100, 3150, 3180, 3200] }
                },
                {
                    id: 'binancecoin',
                    name: 'BNB',
                    symbol: 'bnb',
                    image: 'https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png',
                    current_price: 380,
                    market_cap: 58000000000,
                    market_cap_rank: 3,
                    total_volume: 2800000000,
                    circulating_supply: 153000000,
                    price_change_percentage_24h: 1.8,
                    price_change_percentage_7d_in_currency: 5.7,
                    sparkline_in_7d: { price: [360, 365, 370, 375, 378, 379, 380] }
                }
            ];
            
            cryptoData = mockData;
            filteredData = [...cryptoData];
            
            // Dados globais mock
            totalMarketCap.textContent = '$1.2T';
            totalVolume.textContent = '$45B';
            btcDominance.textContent = '45.2%';
            
            return true;
        }
        
        async function loadCryptoData() {
            // Evitar múltiplas requisições simultâneas
            if (isUpdating) {
                console.log('Atualização já em andamento...');
                return;
            }
            
            // Verificar se precisa atualizar (usar intervalo correto para mobile/desktop)
            const now = Date.now();
            const updateInterval = isMobileData ? MOBILE_UPDATE_INTERVAL : UPDATE_INTERVAL;
            if (now - lastUpdate < updateInterval) {
                const remainingTime = Math.ceil((updateInterval - (now - lastUpdate)) / 1000);
                console.log(`Dados ainda recentes, próxima atualização em ${remainingTime}s...`);
                return;
            }
            
            try {
                isUpdating = true;
                showLoading();
                hideError();
                
                console.log('Tentando carregar dados da API...');
                console.log('Dispositivo móvel:', isMobile);
                
                // Tentar múltiplas estratégias de carregamento
                const success = await tryMultipleLoadStrategies();
                
                if (success) {
                    hideLoading();
                    console.log('Dados carregados com sucesso usando estratégias alternativas');
                } else {
                    throw new Error('Todas as estratégias de carregamento falharam');
                }
                
            } catch (error) {
                console.error('Erro ao carregar dados da API:', error);
                
                // Mensagem de erro específica para dispositivos móveis
                let errorMessage = 'Erro ao carregar dados. ';
                if (isMobile) {
                    errorMessage += 'Verifique sua conexão móvel e tente novamente.';
                } else {
                    errorMessage += 'Verifique sua conexão.';
                }
                
                showError(errorMessage);
                hideLoading();

            } finally {
                isUpdating = false;
            }
        }
        
        // Função para carregar dados globais do mercado (com chave API)
        async function loadGlobalMarketData() {
            try {
                console.log('🔄 Carregando dados globais do mercado (com chave API)...');
                
                // Usar sua chave API do CoinGecko para melhor confiabilidade
                const COINGECKO_API_KEY = 'CG-QGmu3Fbqu6bCfsY2Ntrnq8rK';
                
                const response = await makeRequest(`${COINGECKO_API_BASE}/global?x_cg_demo_api_key=${COINGECKO_API_KEY}`);
                if (response.ok) {
                    const globalData = await response.json();
                    const data = globalData.data;
                    
                    totalMarketCap.textContent = formatCurrency(data.total_market_cap.usd);
                    totalVolume.textContent = formatCurrency(data.total_volume.usd);
                    btcDominance.textContent = `${data.market_cap_percentage.btc.toFixed(1)}%`;
                    
                    console.log('✅ Dados globais carregados com sucesso usando chave API');
                }
            } catch (error) {
                console.error('❌ Erro ao carregar dados globais:', error);
                // Usar dados do cache se disponível
            }
        }
        
        function displayCryptoData() {
            // Mostrar informações específicas para Swing Trade
            if (currentFilter === 'swing-trade') {
                showSwingTradeInfo();
            } else {
                hideSwingTradeInfo();
            }
            
            if (filteredData.length === 0) {
                // Mensagem para desktop
                const colSpan = 9;
                cryptoTableBody.innerHTML = `
                    <tr>
                        <td colspan="${colSpan}" style="text-align: center; padding: 40px;">
                            <p style="color: #a0a0a0;">Nenhuma criptomoeda encontrada.</p>
                        </td>
                    </tr>
                `;
                
                // Mensagem para mobile
                const cryptoListBody = document.getElementById('crypto-list-body');
                if (cryptoListBody) {
                    cryptoListBody.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #a0a0a0;">
                            <p>Nenhuma criptomoeda encontrada.</p>
                        </div>
                    `;
                }
                return;
            }
            
            // Adicionar cabeçalho de ordenação para Swing Trade (desktop)
            let tableHeader = '';
            if (currentFilter === 'swing-trade') {
                tableHeader = `
                    <tr class="sorting-header">
                        <td colspan="9" style="text-align: center; padding: 15px; background: rgba(255, 107, 53, 0.1); border-radius: 8px; margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; color: #ff6b35; font-weight: 600;">
                                <i class="fas fa-sort-amount-down"></i>
                                <span>Ordenado por Score de Swing Trade (Maior para Menor)</span>
                            </div>
                        </td>
                    </tr>
                `;
            }
        
            // Renderizar tabela desktop
            cryptoTableBody.innerHTML = tableHeader + filteredData.map((crypto, index) => {
                const priceChange24h = crypto.price_change_percentage_24h;
                const priceChange7d = crypto.price_change_percentage_7d_in_currency;
                
                // Calcular score de swing trade se necessário
                let swingTradeInfo = '';
                if (currentFilter === 'swing-trade') {
                    const score = getSwingTradeScore(crypto);
                    swingTradeInfo = `
                        <div class="swing-trade-score" style="margin-top: 8px;">
                            <div class="score-bar">
                                <div class="score-fill" style="width: ${score.percentage}%; background: ${getScoreColor(score.percentage)};"></div>
                            </div>
                            <span class="score-text" style="font-size: 0.8rem; color: ${getScoreColor(score.percentage)};">
                                Score: ${score.percentage}%
                            </span>
                        </div>
                    `;
                }
                
                // Versão completa para desktop
                return `
                    <tr onclick="showCryptoDetails('${crypto.id}')">
                        <td>${crypto.market_cap_rank || 'N/A'}</td>
                        <td>
                            <div class="crypto-name">
                                <img src="${crypto.image}" alt="${crypto.name}" class="crypto-icon" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTYiIGZpbGw9IiMwMGQ0YWEiLz4KPHN2ZyB4PSI4IiB5PSI4IiB3aWR0aD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTYiIGZpbGw9IiMwMGQ0YWEiLz4KPHN2ZyB4PSI4IiB5PSI4IiB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0id2hpdGUiPgo8cGF0aCBkPSJNOCA0TDEyIDhMOCAxMkw0IDhMOCA0WiIgZmlsbD0id2hpdGUiPgo8L3N2Zz4KPC9zdmc+Cg=='">
                                <div class="crypto-info">
                                    <h3>${crypto.name}</h3>
                                    <span class="crypto-symbol">${crypto.symbol.toUpperCase()}</span>
                                    ${swingTradeInfo}
                                </div>
                            </div>
                        </td>
                        <td class="price">${formatCurrency(crypto.current_price)}</td>
                        <td>
                            <span class="percentage ${priceChange24h >= 0 ? 'positive' : 'negative'}">
                                ${priceChange24h >= 0 ? '+' : ''}${priceChange24h.toFixed(2)}%
                            </span>
                        </td>
                        <td>
                            <span class="percentage ${priceChange7d >= 0 ? 'positive' : 'negative'}">
                                ${priceChange7d >= 0 ? '+' : ''}${priceChange7d.toFixed(2)}%
                            </span>
                        </td>
                        <td class="market-cap">${formatCurrency(crypto.market_cap)}</td>
                        <td class="volume">${formatCurrency(crypto.total_volume)}</td>
                        <td class="circulation">${formatNumber(crypto.circulating_supply)} ${crypto.symbol.toUpperCase()}</td>
                        <td>
                            <div class="sparkline-chart" data-sparkline="${crypto.sparkline_in_7d?.price?.join(',') || ''}">
                                <!-- Gráfico sparkline será renderizado aqui -->
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
            
            // Renderizar lista mobile
            const cryptoListBody = document.getElementById('crypto-list-body');
            if (cryptoListBody) {
                cryptoListBody.innerHTML = filteredData.map((crypto, index) => {
                    const priceChange24h = crypto.price_change_percentage_24h;
                    const priceChange7d = crypto.price_change_percentage_7d_in_currency;
                    
                    // Calcular score de swing trade se necessário
                    let swingTradeInfo = '';
                    if (currentFilter === 'swing-trade') {
                        const score = getSwingTradeScore(crypto);
                        swingTradeInfo = `
                            <div class="swing-trade-score-mobile">
                                <div class="score-bar-mobile">
                                    <div class="score-fill-mobile" style="width: ${score.percentage}%; background: ${getScoreColor(score.percentage)};"></div>
                                </div>
                                <span class="score-text-mobile" style="color: ${getScoreColor(score.percentage)};">
                                    Score: ${score.percentage}%
                                </span>
                            </div>
                        `;
                    }
                    
                    return `
                        <div class="crypto-card" onclick="showCryptoDetails('${crypto.id}')">
                            <div class="col-name">
                                <i class="fas fa-star favorite-star" onclick="event.stopPropagation(); toggleFavorite('${crypto.id}')"></i>
                                <img src="${crypto.image}" alt="${crypto.name}" class="crypto-icon" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTYiIGZpbGw9IiMwMGQ0YWEiLz4KPHN2ZyB4PSI4IiB5PSI4IiB3aWR0aD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTYiIGZpbGw9IiMwMGQ0YWEiLz4KPHN2ZyB4PSI4IiB5PSI4IiB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0id2hpdGUiPgo8cGF0aCBkPSJNOCA0TDEyIDhMOCAxMkw0IDhMOCA0WiIgZmlsbD0id2hpdGUiPgo8L3N2Zz4KPC9zdmc+Cg=='">
                                <div class="crypto-info-mobile">
                                    <h3>${crypto.name}</h3>
                                    <span class="crypto-symbol-mobile">${crypto.symbol.toUpperCase()}</span>
                                    ${swingTradeInfo}
                                </div>
                                <button class="buy-btn">Buy</button>
                            </div>
                            <div class="col-24h">
                                <span class="percentage-mobile ${priceChange24h >= 0 ? 'positive' : 'negative'}">
                                    ${priceChange24h >= 0 ? '+' : ''}${priceChange24h.toFixed(2)}%
                                </span>
                            </div>
                            <div class="col-7d">
                                <span class="percentage-mobile ${priceChange7d >= 0 ? 'positive' : 'negative'}">
                                    ${priceChange7d >= 0 ? '+' : ''}${priceChange7d.toFixed(2)}%
                                </span>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // Renderizar gráficos sparkline apenas em desktop
            if (!isMobile) {
                renderSparklines();
            }
        }
        

        

        
        function filterAndDisplayData() {
            filteredData = cryptoData.filter(crypto => {
                const matchesSearch = crypto.name.toLowerCase().includes(searchTerm) || 
                                    crypto.symbol.toLowerCase().includes(searchTerm);
                
                if (!matchesSearch) return false;
                
                switch (currentFilter) {
                    case 'gainers':
                        return crypto.price_change_percentage_24h > 0;
                    case 'losers':
                        return crypto.price_change_percentage_24h < 0;
                    case 'swing-trade':
                        return isGoodSwingTrade(crypto);
                    default:
                        return true;
                }
            });
            
            // Ordenar dados baseado no filtro ativo
            sortFilteredData();
            
            displayCryptoData();
        }
        
        // Função para ordenar dados baseado no filtro ativo
        function sortFilteredData() {
            switch (currentFilter) {
                case 'swing-trade':
                    // Ordenar por score de swing trade (maior para menor)
                    filteredData.sort((a, b) => {
                        const scoreA = getSwingTradeScore(a).percentage;
                        const scoreB = getSwingTradeScore(b).percentage;
                        return scoreB - scoreA; // Ordem decrescente (maior score primeiro)
                    });
                    break;
                    
                case 'gainers':
                    // Ordenar por maior ganho em 24h
                    filteredData.sort((a, b) => {
                        return b.price_change_percentage_24h - a.price_change_percentage_24h;
                    });
                    break;
                    
                case 'losers':
                    // Ordenar por menor perda em 24h (menos negativo primeiro)
                    filteredData.sort((a, b) => {
                        return a.price_change_percentage_24h - b.price_change_percentage_24h;
                    });
                    break;
                    
                default:
                    // Manter ordem original por market cap rank
                    filteredData.sort((a, b) => {
                        return (a.market_cap_rank || 999) - (b.market_cap_rank || 999);
                    });
                    break;
            }
        }
        
        function isGoodSwingTrade(crypto) {
            // Sistema de pontuação para Swing Trade (0-100 pontos)
            let score = 0;
            const maxScore = 100;
            
            // 1. ANÁLISE DE VOLUME E LIQUIDEZ (25 pontos)
            const volumeScore = analyzeVolume(crypto.total_volume, crypto.market_cap);
            score += volumeScore;
            
            // 2. ANÁLISE DE MOMENTUM E TENDÊNCIA (30 pontos)
            const momentumScore = analyzeMomentum(crypto.price_change_percentage_24h, crypto.price_change_percentage_7d_in_currency);
            score += momentumScore;
            
            // 3. ANÁLISE DE CAPITALIZAÇÃO (20 pontos)
            const marketCapScore = analyzeMarketCap(crypto.market_cap);
            score += marketCapScore;
            
            // 4. ANÁLISE DE VOLATILIDADE (15 pontos)
            const volatilityScore = analyzeVolatility(crypto.price_change_percentage_24h, crypto.price_change_percentage_7d_in_currency);
            score += volatilityScore;
            
            // 5. ANÁLISE DE RANKING E ESTABILIDADE (10 pontos)
            const stabilityScore = analyzeStability(crypto.market_cap_rank);
            score += stabilityScore;
            
            // Retorna true se a pontuação for >= 70 (70% de aprovação)
            return score >= 70;
        }
        
        function analyzeVolume(volume, marketCap) {
            // Volume mínimo absoluto: $5M
            if (volume < 5000000) return 0;
            
            // Volume relativo ao market cap (ideal: 5-20% do market cap em 24h)
            const volumeToMarketCapRatio = volume / marketCap;
            
            if (volumeToMarketCapRatio >= 0.05 && volumeToMarketCapRatio <= 0.20) {
                return 25; // Volume ideal
            } else if (volumeToMarketCapRatio >= 0.02 && volumeToMarketCapRatio < 0.05) {
                return 20; // Volume bom
            } else if (volumeToMarketCapRatio >= 0.01 && volumeToMarketCapRatio < 0.02) {
                return 15; // Volume aceitável
            } else if (volumeToMarketCapRatio > 0.20) {
                return 10; // Volume muito alto (pode indicar manipulação)
            } else {
                return 5; // Volume baixo
            }
        }
        
        function analyzeMomentum(change24h, change7d) {
            let score = 0;
            
            // ANÁLISE 24H (15 pontos)
            if (change24h >= 3 && change24h <= 15) {
                score += 15; // Momentum ideal para swing trade
            } else if (change24h >= 1 && change24h < 3) {
                score += 12; // Momentum bom, mas pode ser muito conservador
            } else if (change24h > 15 && change24h <= 25) {
                score += 8; // Momentum forte, mas pode ser muito agressivo
            } else if (change24h > 25) {
                score += 3; // Momentum muito forte (risco de correção)
            } else if (change24h >= -5 && change24h < 1) {
                score += 5; // Momentum neutro/leve negativo
            } else {
                score += 0; // Momentum muito negativo
            }
            
            // ANÁLISE 7 DIAS (15 pontos)
            if (change7d >= -10 && change7d <= 30) {
                score += 15; // Tendência ideal
            } else if (change7d > 30 && change7d <= 50) {
                score += 10; // Tendência forte, mas pode ser excessiva
            } else if (change7d >= -20 && change7d < -10) {
                score += 8; // Tendência levemente negativa, mas recuperável
            } else if (change7d > 50) {
                score += 5; // Tendência muito forte (risco de correção)
            } else if (change7d < -20) {
                score += 2; // Tendência muito negativa
            } else {
                score += 0;
            }
            
            return score;
        }
        
        function analyzeMarketCap(marketCap) {
            // Ideal: $100M - $5B (moedas com liquidez mas não muito grandes)
            if (marketCap >= 100000000 && marketCap <= 5000000000) {
                return 20; // Faixa ideal
            } else if (marketCap >= 50000000 && marketCap < 100000000) {
                return 15; // Faixa boa
            } else if (marketCap > 5000000000 && marketCap <= 10000000000) {
                return 12; // Faixa aceitável (moedas maiores)
            } else if (marketCap >= 10000000 && marketCap < 50000000) {
                return 8; // Faixa pequena (mais risco)
            } else if (marketCap > 10000000000) {
                return 5; // Moedas muito grandes (menos volatilidade)
            } else {
                return 0; // Muito pequenas (alto risco)
            }
        }
        
        function analyzeVolatility(change24h, change7d) {
            let score = 15;
            
            // Penalizar volatilidade excessiva
            const abs24h = Math.abs(change24h);
            const abs7d = Math.abs(change7d);
            
            if (abs24h > 40) {
                score -= 8; // Muito volátil
            } else if (abs24h > 30) {
                score -= 5; // Volátil
            } else if (abs24h > 20) {
                score -= 3; // Moderadamente volátil
            }
            
            if (abs7d > 60) {
                score -= 5; // Tendência muito volátil
            } else if (abs7d > 40) {
                score -= 3; // Tendência volátil
            }
            
            // Bonus para volatilidade controlada (ideal para swing trade)
            if (abs24h >= 5 && abs24h <= 20 && abs7d >= 10 && abs7d <= 40) {
                score += 3;
            }
            
            return Math.max(0, score);
        }
        
        function analyzeStability(rank) {
            if (!rank) return 5;
            
            // Moedas com ranking estável (não muito altas, não muito baixas)
            if (rank >= 20 && rank <= 100) {
                return 10; // Ranking ideal
            } else if (rank >= 10 && rank < 20) {
                return 8; // Ranking bom
            } else if (rank > 100 && rank <= 200) {
                return 6; // Ranking aceitável
            } else if (rank >= 5 && rank < 10) {
                return 4; // Ranking alto (menos volatilidade)
            } else if (rank > 200) {
                return 2; // Ranking baixo (mais risco)
            } else {
                return 0;
            }
        }
        
        // Função para calcular e exibir o score de swing trade
        function getSwingTradeScore(crypto) {
            let score = 0;
            const maxScore = 100;
            
            score += analyzeVolume(crypto.total_volume, crypto.market_cap);
            score += analyzeMomentum(crypto.price_change_percentage_24h, crypto.price_change_percentage_7d_in_currency);
            score += analyzeMarketCap(crypto.market_cap);
            score += analyzeVolatility(crypto.price_change_percentage_24h, crypto.price_change_percentage_7d_in_currency);
            score += analyzeStability(crypto.market_cap_rank);
            
            return {
                total: score,
                percentage: Math.round((score / maxScore) * 100),
                volume: analyzeVolume(crypto.total_volume, crypto.market_cap),
                momentum: analyzeMomentum(crypto.price_change_percentage_24h, crypto.price_change_percentage_7d_in_currency),
                marketCap: analyzeMarketCap(crypto.market_cap),
                volatility: analyzeVolatility(crypto.price_change_percentage_24h, crypto.price_change_percentage_7d_in_currency),
                stability: analyzeStability(crypto.market_cap_rank)
            };
        }
        
        function renderSparklines() {
            document.querySelectorAll('.sparkline-chart').forEach(chart => {
                const sparklineData = chart.dataset.sparkline;
                if (sparklineData) {
                    const prices = sparklineData.split(',').map(Number);
                    if (prices.length > 1) {
                        chart.innerHTML = createSparklineSVG(prices);
                    }
                }
            });
        }
        
        function createSparklineSVG(prices) {
            if (prices.length < 2) return '';
            
            const width = 120;
            const height = 40;
            const padding = 5;
            const chartWidth = width - (padding * 2);
            const chartHeight = height - (padding * 2);
            
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice;
            
            if (priceRange === 0) return '';
            
            const points = prices.map((price, index) => {
                const x = padding + (index / (prices.length - 1)) * chartWidth;
                const y = padding + chartHeight - ((price - minPrice) / priceRange) * chartHeight;
                return `${x},${y}`;
            }).join(' ');
            
            const isPositive = prices[prices.length - 1] >= prices[0];
            const strokeColor = isPositive ? '#00d4aa' : '#ff6b6b';
            
            return `
                <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
                    <polyline 
                        points="${points}" 
                        fill="none" 
                        stroke="${strokeColor}" 
                        stroke-width="2"
                        vector-effect="non-scaling-stroke"
                    />
                </svg>
            `;
        }
        
        function showCryptoDetails(cryptoId) {
            const crypto = cryptoData.find(c => c.id === cryptoId);
            if (!crypto) return;
            
            const modal = document.getElementById('crypto-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            
            modalTitle.textContent = crypto.name;
            
            const priceChange24h = crypto.price_change_percentage_24h;
            const priceChange7d = crypto.price_change_percentage_7d_in_currency;
            
            modalBody.innerHTML = `
                <div class="crypto-details">
                    <div class="crypto-header">
                        <div class="crypto-basic-info">
                            <img src="${crypto.image}" alt="${crypto.name}" style="width: 64px; height: 64px; border-radius: 50%;">
                            <div>
                                <h3 style="font-size: 1.8rem; margin-bottom: 8px;">${crypto.name}</h3>
                                <p style="color: #a0a0a0; font-size: 1.2rem;">${crypto.symbol.toUpperCase()}</p>
                            </div>
                        </div>
                        <div class="crypto-price-info">
                            <h2 style="font-size: 2.5rem; margin-bottom: 16px;">${formatCurrency(crypto.current_price)}</h2>
                            <div style="display: flex; gap: 16px;">
                                <span class="percentage ${priceChange24h >= 0 ? 'positive' : 'negative'}">
                                    ${priceChange24h >= 0 ? '+' : ''}${priceChange24h.toFixed(2)}% (24h)
                                </span>
                                <span class="percentage ${priceChange7d >= 0 ? 'positive' : 'negative'}">
                                    ${priceChange7d >= 0 ? '+' : ''}${priceChange7d.toFixed(2)}% (7d)
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="crypto-stats" style="margin-top: 32px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div class="stat-card">
                                <h4 style="color: #a0a0a0; margin-bottom: 8px;">Cap. de Mercado</h4>
                                <p style="font-size: 1.2rem; font-weight: 600;">${formatCurrency(crypto.market_cap)}</p>
                            </div>
                            <div class="stat-card">
                                <h4 style="color: #a0a0a0; margin-bottom: 8px;">Volume (24h)</h4>
                                <p style="font-size: 1.2rem; font-weight: 600;">${formatCurrency(crypto.total_volume)}</p>
                            </div>
                            <div class="stat-card">
                                <h4 style="color: #a0a0a0; margin-bottom: 8px;">Circulação</h4>
                                <p style="font-size: 1.2rem; font-weight: 600;">${formatNumber(crypto.circulating_supply)} ${crypto.symbol.toUpperCase()}</p>
                            </div>
                            <div class="stat-card">
                                <h4 style="color: #a0a0a0; margin-bottom: 8px;">Ranking</h4>
                                <p style="font-size: 1.2rem; font-weight: 600;">#${crypto.market_cap_rank || 'N/A'}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="crypto-chart" style="margin-top: 32px;">
                        <h4 style="color: #a0a0a0; margin-bottom: 16px;">Preço nos últimos 7 dias</h4>
                        <div style="width: 100%; height: 200px; background: rgba(255,255,255,0.05); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <p style="color: #a0a0a0;">Gráfico interativo seria renderizado aqui</p>
                        </div>
                    </div>
                    
                    ${currentFilter === 'swing-trade' ? `
                    <div class="swing-trade-analysis" style="margin-top: 32px;">
                        <h4 style="color: #a0a0a0; margin-bottom: 16px;">📊 Análise de Swing Trade</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                            <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                <div style="font-size: 1.5rem; font-weight: 700; color: #ff6b35; margin-bottom: 5px;">
                                    ${getSwingTradeScore(crypto).percentage}%
                                </div>
                                <div style="font-size: 0.8rem; color: #a0a0a0;">Score Total</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                <div style="font-size: 1.2rem; font-weight: 600; color: #00d4aa; margin-bottom: 5px;">
                                    ${getSwingTradeScore(crypto).volume}/25
                                </div>
                                <div style="font-size: 0.8rem; color: #a0a0a0;">Volume</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                <div style="font-size: 1.2rem; font-weight: 600; color: #0099cc; margin-bottom: 5px;">
                                    ${getSwingTradeScore(crypto).momentum}/30
                                </div>
                                <div style="font-size: 0.8rem; color: #a0a0a0;">Momentum</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                <div style="font-size: 1.2rem; font-weight: 600; color: #ffa500; margin-bottom: 5px;">
                                    ${getSwingTradeScore(crypto).marketCap}/20
                                </div>
                                <div style="font-size: 0.8rem; color: #a0a0a0;">Market Cap</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                <div style="font-size: 1.2rem; font-weight: 600; color: #ff6b35; margin-bottom: 5px;">
                                    ${getSwingTradeScore(crypto).volatility}/15
                                </div>
                                <div style="font-size: 0.8rem; color: #a0a0a0;">Volatilidade</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                <div style="font-size: 1.2rem; font-weight: 600; color: #a0a0a0; margin-bottom: 5px;">
                                    ${getSwingTradeScore(crypto).stability}/10
                                </div>
                                <div style="font-size: 0.8rem; color: #a0a0a0;">Estabilidade</div>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;
            
            modal.style.display = 'block';
        }
        
        function closeModal() {
            const modal = document.getElementById('crypto-modal');
            modal.style.display = 'none';
        }
        
        function setupAutoUpdate() {
            // Usar intervalo diferente para mobile e desktop
            const mainInterval = isMobileData ? MOBILE_UPDATE_INTERVAL : UPDATE_INTERVAL;
            const intervalText = isMobileData ? '5 minutos' : '30 segundos';
            
            // Atualização principal
            setInterval(() => {
                if (isMobileData) {
                    // Para mobile, usar API da Binance
                    loadCryptoDataFromBinance();
                } else {
                    // Para desktop/WiFi, usar API da CoinGecko
                    loadCryptoData();
                }
            }, mainInterval);
            
            // Atualização em tempo real para todos os dispositivos
            const realTimeInterval = isMobile ? MOBILE_REAL_TIME_INTERVAL : DESKTOP_REAL_TIME_INTERVAL;
            realTimeUpdateInterval = setInterval(() => {
                updateRealTimePrices();
            }, realTimeInterval);
            
            // Mostrar indicador de tempo real para todos
            if (realTimeIndicator) {
                realTimeIndicator.style.display = 'flex';
            }
            
            console.log(`🔄 Atualizações configuradas: ${intervalText} para dados principais, ${realTimeInterval/1000}s para tempo real`);
        }
        
        // Funções utilitárias
        function formatCurrency(amount) {
            if (amount === null || amount === undefined) return 'N/A';
            
            if (amount >= 1e12) {
                return `$${(amount / 1e12).toFixed(2)}T`;
            } else if (amount >= 1e9) {
                return `$${(amount / 1e9).toFixed(2)}B`;
            } else if (amount >= 1e6) {
                return `$${(amount / 1e6).toFixed(2)}M`;
            } else if (amount >= 1e3) {
                return `$${(amount / 1e3).toFixed(2)}K`;
            } else {
                return `$${amount.toFixed(2)}`;
            }
        }
        
        function formatNumber(num) {
            if (num === null || num === undefined) return 'N/A';
            
            if (num >= 1e12) {
                return `${(num / 1e12).toFixed(2)}T`;
            } else if (num >= 1e9) {
                return `${(num / 1e9).toFixed(2)}B`;
            } else if (num >= 1e6) {
                return `${(num / 1e6).toFixed(2)}M`;
            } else if (num >= 1e3) {
                return `${(num / 1e3).toFixed(2)}K`;
            } else {
                return num.toLocaleString();
            }
        }
        
        function showLoading() {
            loadingElement.style.display = 'block';
            cryptoTableBody.innerHTML = '';
        }
        
        function hideLoading() {
            loadingElement.style.display = 'none';
        }
        
        function showError() {
            errorElement.style.display = 'block';
        }
        
        function hideError() {
            errorElement.style.display = 'none';
        }
        
        // Função para recarregar dados (usada no botão de erro)
        window.loadCryptoData = loadCryptoData;
        window.showCryptoDetails = showCryptoDetails;
        window.closeModal = closeModal;
        
        // Funções auxiliares para Swing Trade
        function getScoreColor(percentage) {
            if (percentage >= 80) return '#00d4aa'; // Verde para scores altos
            if (percentage >= 70) return '#0099cc'; // Azul para scores bons
            if (percentage >= 60) return '#ffa500'; // Laranja para scores médios
            if (percentage >= 50) return '#ff6b35'; // Laranja escuro para scores baixos
            return '#ff6b6b'; // Vermelho para scores muito baixos
        }
        
        function showSwingTradeInfo() {
            // Criar banner informativo sobre swing trade
            let banner = document.getElementById('swing-trade-banner');
            if (!banner) {
                banner = document.createElement('div');
                banner.id = 'swing-trade-banner';
                banner.className = 'swing-trade-banner';
                banner.innerHTML = `
                    <div class="banner-content">
                        <div class="banner-header">
                            <i class="fas fa-chart-line"></i>
                            <h3>🎯 Oportunidades de Swing Trade</h3>
                        </div>
                        <div class="banner-description">
                            <p>Moedas selecionadas com base em critérios técnicos para swing trade de curto prazo (1-7 dias):</p>
                            <ul>
                                <li><strong>Volume:</strong> Liquidez adequada ($5M+ em 24h)</li>
                                <li><strong>Momentum:</strong> Movimento positivo controlado (3-15% em 24h)</li>
                                <li><strong>Market Cap:</strong> Tamanho ideal ($100M - $5B)</li>
                                <li><strong>Volatilidade:</strong> Controle de risco (evita pump & dump)</li>
                                <li><strong>Estabilidade:</strong> Ranking equilibrado (posição 20-100)</li>
                            </ul>
                        </div>
                        <div class="banner-stats">
                            <div class="stat">
                                <span class="stat-number">${filteredData.length}</span>
                                <span class="stat-label">Moedas Selecionadas</span>
                            </div>
                            <div class="stat">
                                <span class="stat-number">${Math.round(filteredData.reduce((acc, crypto) => acc + getSwingTradeScore(crypto).percentage, 0) / filteredData.length)}%</span>
                                <span class="stat-label">Score Médio</span>
                            </div>
                            <div class="stat">
                                <span class="stat-number">🎯</span>
                                <span class="stat-label">Ordenado por Score</span>
                            </div>
                        </div>
                    </div>
                `;
                
                // Inserir antes da tabela
                const tableContainer = document.querySelector('.crypto-table-container');
                tableContainer.parentNode.insertBefore(banner, tableContainer);
            }
            banner.style.display = 'block';
        }
        
        function hideSwingTradeInfo() {
            const banner = document.getElementById('swing-trade-banner');
            if (banner) {
                banner.style.display = 'none';
            }
        }
        
        // ===== FUNÇÕES DE ATUALIZAÇÃO EM TEMPO REAL =====
        
        function savePreviousPrices() {
            previousPrices.clear();
            cryptoData.forEach(crypto => {
                previousPrices.set(crypto.id, {
                    price: crypto.current_price,
                    change24h: crypto.price_change_percentage_24h,
                    change7d: crypto.price_change_percentage_7d_in_currency,
                    volume: crypto.total_volume,
                    marketCap: crypto.market_cap
                });
            });
        }
        
        async function updateRealTimePrices() {
            if (isUpdating) return; // Evitar conflitos com atualização principal
            
            try {
                // Buscar apenas dados essenciais para atualização rápida
                const response = await makeRequest(`${COINGECKO_API_BASE}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false&price_change_percentage=24h,7d`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const newData = await response.json();
                    updatePricesInRealTime(newData);
                }
            } catch (error) {
                console.log('Erro na atualização em tempo real:', error);
                // Não mostrar erro para o usuário, apenas log
            }
        }
        
        function updatePricesInRealTime(newData) {
            newData.forEach(newCrypto => {
                const oldCrypto = cryptoData.find(c => c.id === newCrypto.id);
                if (oldCrypto) {
                    const oldPrice = oldCrypto.current_price;
                    const newPrice = newCrypto.current_price;
                    
                    // Atualizar dados
                    oldCrypto.current_price = newPrice;
                    oldCrypto.price_change_percentage_24h = newCrypto.price_change_percentage_24h;
                    oldCrypto.price_change_percentage_7d_in_currency = newCrypto.price_change_percentage_7d_in_currency;
                    oldCrypto.total_volume = newCrypto.total_volume;
                    oldCrypto.market_cap = newCrypto.market_cap;
                    
                    // Atualizar visualmente se a linha estiver visível
                    updatePriceDisplay(oldCrypto, oldPrice, newPrice);
                }
            });
            
            // Atualizar dados globais se necessário
            updateGlobalStatsInRealTime(newData);
        }
        
        function updatePriceDisplay(crypto, oldPrice, newPrice) {
            const row = document.querySelector(`tr[onclick*="${crypto.id}"]`);
            if (!row) return;
            
            // Atualizar preço
            const priceCell = row.querySelector('.price');
            if (priceCell) {
                const priceChange = newPrice - oldPrice;
                const isPositive = priceChange >= 0;
                
                // Adicionar classe de animação
                priceCell.classList.add('price-updating');
                
                // Atualizar valor
                priceCell.textContent = formatCurrency(newPrice);
                
                // Adicionar indicador visual de mudança
                if (Math.abs(priceChange) > 0.01) { // Mudança maior que 1 centavo
                    priceCell.classList.add(isPositive ? 'price-up' : 'price-down');
                    
                    // Remover classes após animação
                    setTimeout(() => {
                        priceCell.classList.remove('price-up', 'price-down', 'price-updating');
                    }, 2000);
                }
            }
            
            // Atualizar mudanças percentuais
            const change24hCell = row.querySelector('td:nth-child(4) .percentage');
            const change7dCell = row.querySelector('td:nth-child(5) .percentage');
            
            if (change24hCell) {
                const change24h = crypto.price_change_percentage_24h;
                change24hCell.textContent = `${change24h >= 0 ? '+' : ''}${change24h.toFixed(2)}%`;
                change24hCell.className = `percentage ${change24h >= 0 ? 'positive' : 'negative'}`;
            }
            
            if (change7dCell) {
                const change7d = crypto.price_change_percentage_7d_in_currency;
                change7dCell.textContent = `${change7d >= 0 ? '+' : ''}${change7d.toFixed(2)}%`;
                change7dCell.className = `percentage ${change7d >= 0 ? 'positive' : 'negative'}`;
            }
            
            // Atualizar volume e market cap
            const volumeCell = row.querySelector('.volume');
            const marketCapCell = row.querySelector('.market-cap');
            
            if (volumeCell) {
                volumeCell.textContent = formatCurrency(crypto.total_volume);
            }
            
            if (marketCapCell) {
                marketCapCell.textContent = formatCurrency(crypto.market_cap);
            }
        }
        
        function updateGlobalStatsInRealTime(newData) {
            // Calcular novos totais
            const totalMarketCap = newData.reduce((sum, crypto) => sum + crypto.market_cap, 0);
            const totalVolume = newData.reduce((sum, crypto) => sum + crypto.total_volume, 0);
            
            // Atualizar elementos do header
            const marketCapElement = document.getElementById('total-market-cap');
            const volumeElement = document.getElementById('total-volume');
            
            if (marketCapElement) {
                marketCapElement.textContent = formatCurrency(totalMarketCap);
            }
            
            if (volumeElement) {
                volumeElement.textContent = formatCurrency(totalVolume);
            }
        }
        
        // Função para parar atualizações em tempo real (útil para economizar recursos)
        function stopRealTimeUpdates() {
            if (realTimeUpdateInterval) {
                clearInterval(realTimeUpdateInterval);
                realTimeUpdateInterval = null;
                console.log('Atualizações em tempo real paradas');
                
                // Ocultar indicador
                if (realTimeIndicator) {
                    realTimeIndicator.style.display = 'none';
                }
            }
        }
        
        // Função para retomar atualizações em tempo real
        function resumeRealTimeUpdates() {
            if (!realTimeUpdateInterval) {
                const realTimeInterval = isMobile ? MOBILE_REAL_TIME_INTERVAL : DESKTOP_REAL_TIME_INTERVAL;
                realTimeUpdateInterval = setInterval(() => {
                    updateRealTimePrices();
                }, realTimeInterval);
                console.log('Atualizações em tempo real retomadas');
                
                // Mostrar indicador
                if (realTimeIndicator) {
                    realTimeIndicator.style.display = 'flex';
                }
            }
        }
        
        // Adicionar ao objeto window para uso global
        window.stopRealTimeUpdates = stopRealTimeUpdates;
        window.resumeRealTimeUpdates = resumeRealTimeUpdates;
        
        // Função para adicionar indicador de scroll horizontal em mobile
        function addScrollIndicator() {
            if (!isMobile) return;
            
            const tableContainer = document.querySelector('.crypto-table-container');
            if (!tableContainer) return;
            
            // Criar indicador de scroll direito
            const rightScrollHint = document.createElement('div');
            rightScrollHint.className = 'scroll-hint';
            rightScrollHint.innerHTML = `
                <i class="fas fa-chevron-right"></i>
                <span>Deslize →</span>
            `;
            
            // Criar indicador de scroll esquerdo
            const leftScrollHint = document.createElement('div');
            leftScrollHint.className = 'scroll-hint left';
            leftScrollHint.innerHTML = `
                <i class="fas fa-chevron-left"></i>
                <span>← Deslize</span>
            `;
            
            tableContainer.appendChild(rightScrollHint);
            tableContainer.appendChild(leftScrollHint);
            
            // Mostrar indicadores inicialmente
            rightScrollHint.style.display = 'block';
            leftScrollHint.style.display = 'none';
            
            // Adicionar evento de scroll para mostrar/ocultar indicadores
            tableContainer.addEventListener('scroll', function() {
                const scrollLeft = this.scrollLeft;
                const maxScrollLeft = this.scrollWidth - this.clientWidth;
                
                // Mostrar/ocultar indicador direito
                if (scrollLeft >= maxScrollLeft - 10) {
                    rightScrollHint.style.display = 'none';
                } else {
                    rightScrollHint.style.display = 'block';
                }
                
                // Mostrar/ocultar indicador esquerdo
                if (scrollLeft <= 10) {
                    leftScrollHint.style.display = 'none';
                } else {
                    leftScrollHint.style.display = 'block';
                }
            });
            
            // Remover indicadores após alguns segundos de inatividade
            let hideTimeout;
            const hideIndicators = () => {
                hideTimeout = setTimeout(() => {
                    rightScrollHint.style.opacity = '0';
                    leftScrollHint.style.opacity = '0';
                    setTimeout(() => {
                        if (rightScrollHint.parentNode) {
                            rightScrollHint.parentNode.removeChild(rightScrollHint);
                        }
                        if (leftScrollHint.parentNode) {
                            leftScrollHint.parentNode.removeChild(leftScrollHint);
                        }
                    }, 500);
                }, 8000);
            };
            
            // Resetar timeout quando houver scroll
            tableContainer.addEventListener('scroll', () => {
                clearTimeout(hideTimeout);
                rightScrollHint.style.opacity = '1';
                leftScrollHint.style.opacity = '1';
                hideIndicators();
            });
            
            // Iniciar contador para ocultar
            hideIndicators();
        }
        
        // Função para detectar problemas de rede móvel
        function detectMobileNetworkIssues() {
            if (!isMobile) return false;
            
            // Verificar se há conexão com internet
            if (!navigator.onLine) {
                return 'Sem conexão com internet';
            }
            
            // Verificar se é uma conexão móvel lenta
            if ('connection' in navigator) {
                const connection = navigator.connection;
                if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
                    return 'Conexão móvel muito lenta';
                }
            }
            
            return false;
        }
        
        // Função para detectar se está usando dados móveis
        function detectMobileDataUsage() {
            if (!isMobile) return false;
            
            // Verificar se há conexão com internet
            if (!navigator.onLine) return false;
            
            // Verificar se é uma conexão móvel
            if ('connection' in navigator) {
                const connection = navigator.connection;
                
                // Se não tem WiFi, provavelmente é dados móveis
                if (connection.type === 'cellular') {
                    isMobileData = true;
                    console.log('📱 Dados móveis detectados');
                    
                    // Detectar conexões muito lentas
                    const isVerySlowConnection = connection.rtt > 200 || 
                                               connection.downlink < 1 || 
                                               connection.effectiveType === 'slow-2g';
                    
                    if (isVerySlowConnection) {
                        console.log('⚠️ Conexão muito lenta detectada! Ajustando configurações...');
                        showWarning('⚠️ Conexão muito lenta detectada. Ajustando para melhor performance...');
                        
                        // Ajustar intervalos para conexões muito lentas
                        MOBILE_UPDATE_INTERVAL = 10 * 60 * 1000; // 10 minutos para conexões muito lentas
                        console.log('⏱️ Intervalo de atualização ajustado para 10 minutos (conexão muito lenta)');
                    }
                    
                    return true;
                }
                
                // Verificar se é uma conexão lenta (provavelmente dados móveis)
                if (connection.effectiveType === '2g' || connection.effectiveType === '3g') {
                    isMobileData = true;
                    console.log('📱 Dados móveis lentos detectados');
                    
                    // Ajustar para conexões lentas
                    if (connection.effectiveType === '2g' || connection.effectiveType === 'slow-2g') {
                        MOBILE_UPDATE_INTERVAL = 8 * 60 * 1000; // 8 minutos para 2G
                        console.log('⏱️ Intervalo ajustado para 8 minutos (conexão 2G)');
                    }
                    
                    return true;
                }
            }
            
            // Fallback: se não consegue detectar, assume que é dados móveis em dispositivos móveis
            if (isMobile) {
                isMobileData = true;
                console.log('📱 Assumindo dados móveis (detecção automática)');
                return true;
            }
            
            return false;
        }
        

        
        // Função para mostrar aviso
        function showWarning(message) {
            // Criar aviso temporário
            const warning = document.createElement('div');
            warning.className = 'warning-message';
            warning.innerHTML = `
                <div class="warning-content">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span>${message}</span>
                </div>
            `;
            
            document.body.appendChild(warning);
            
            // Remover após 5 segundos
            setTimeout(() => {
                if (warning.parentNode) {
                    warning.parentNode.removeChild(warning);
                }
            }, 5000);
        }
        
        // Função para tentar múltiplas estratégias de carregamento
        async function tryMultipleLoadStrategies() {
            console.log('Tentando múltiplas estratégias de carregamento...');
            console.log('📱 Dados móveis:', isMobileData ? 'Sim' : 'Não');
            
            // Estratégia 1: API principal
            try {
                console.log('🔄 Tentando Estratégia 1: API principal...');
                const response = await makeRequest(`${COINGECKO_API_BASE}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=true&price_change_percentage=24h,7d`, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Salvar preços anteriores para comparação
                    savePreviousPrices();
                    
                    cryptoData = data;
                    filteredData = [...cryptoData];
                    await loadGlobalMarketData();
                    saveToCache(data);
                    displayCryptoData();
                    console.log('✅ Estratégia 1 (API principal) funcionou');
                    return true;
                }
            } catch (error) {
                console.log('❌ Estratégia 1 falhou:', error);
            }
            
            // Estratégia 2: API com menos dados (sem sparkline)
            try {
                console.log('🔄 Tentando Estratégia 2: API sem sparkline...');
                const response = await makeRequest(`${COINGECKO_API_BASE}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false&price_change_percentage=24h,7d`, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Salvar preços anteriores para comparação
                    savePreviousPrices();
                    
                    cryptoData = data;
                    filteredData = [...cryptoData];
                    await loadGlobalMarketData();
                    saveToCache(data);
                    displayCryptoData();
                    console.log('✅ Estratégia 2 (API sem sparkline) funcionou');
                    return true;
                }
            } catch (error) {
                console.log('❌ Estratégia 2 falhou:', error);
            }
            
                    // MOBILE: Usar apenas CoinGecko com chave API
        if (isMobileData) {
            console.log('📱 MOBILE: Usando exclusivamente CoinGecko com chave API...');
            
            try {
                const success = await loadCryptoDataFromCoinGecko();
                if (success) {
                    console.log('✅ CoinGecko funcionou no mobile!');
                    return true;
                } else {
                    console.log('❌ CoinGecko falhou no mobile');
                    return false;
                }
            } catch (error) {
                console.log('❌ Erro ao carregar dados da CoinGecko no mobile:', error.message);
                return false;
            }
        }
            
            // Estratégia 3: Cache local
            if (loadFromCache()) {
                displayCryptoData();
                console.log('✅ Estratégia 3 (Cache local) funcionou');
                return true;
            }
            
            // Estratégia 4: Dados mock
            if (loadMockData()) {
                displayCryptoData();
                console.log('✅ Estratégia 4 (Dados mock) funcionou');
                return true;
            }
            
            console.log('❌ Todas as estratégias falharam');
            return false;
        }
        
        // Função para testar conectividade em dispositivos móveis
        async function testMobileConnectivity() {
            if (!isMobile) return;
            
            showWarning('🔍 Testando conectividade...');
            
            try {
                // Teste 1: Verificar se está online
                if (!navigator.onLine) {
                    showWarning('❌ Sem conexão com internet');
                    return;
                }
                
                // Teste 2: Detectar tipo de conexão
                let connectionInfo = 'Desconhecida';
                if ('connection' in navigator) {
                    const connection = navigator.connection;
                    connectionInfo = `${connection.type || 'Desconhecido'} - ${connection.effectiveType || 'Desconhecido'}`;
                    
                    // Análise detalhada da qualidade da conexão
                    console.log('📊 Análise da conexão:', {
                        type: connection.type,
                        effectiveType: connection.effectiveType,
                        rtt: connection.rtt,
                        downlink: connection.downlink,
                        saveData: connection.saveData
                    });
                }
                showWarning(`📡 Tipo de conexão: ${connectionInfo}`);
                
                // Mostrar qual API será usada
                const apiSource = isMobileData ? 'CoinGecko API (Chave)' : 'CoinGecko API (Chave)';
                const updateInterval = isMobileData ? `${MOBILE_UPDATE_INTERVAL / 60000} minutos` : `${UPDATE_INTERVAL / 1000} segundos`;
                showWarning(`🔌 API: ${apiSource} - Atualizações: ${updateInterval}`);
                
                // Teste 3: Tentar fazer uma requisição simples
                showWarning('🔄 Testando conectividade básica...');
                const startTime = Date.now();
                const testResponse = await makeRequest('https://httpbin.org/get', {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });
                const endTime = Date.now();
                const responseTime = endTime - startTime;
                
                if (testResponse.ok) {
                    // Análise da qualidade da conexão baseada no tempo de resposta
                    let connectionQuality = 'Excelente';
                    let recommendations = [];
                    
                    if (responseTime > 8000) {
                        connectionQuality = 'Muito Lenta';
                        recommendations.push('Considere usar WiFi');
                        recommendations.push('Verifique cobertura da operadora');
                        if (isMobileData) {
                            MOBILE_UPDATE_INTERVAL = 15 * 60 * 1000; // 15 minutos
                            console.log('⏱️ Intervalo ajustado para 15 minutos (conexão muito lenta)');
                        }
                    } else if (responseTime > 5000) {
                        connectionQuality = 'Lenta';
                        recommendations.push('Conexão pode ser instável');
                        if (isMobileData) {
                            MOBILE_UPDATE_INTERVAL = 10 * 60 * 1000; // 10 minutos
                            console.log('⏱️ Intervalo ajustado para 10 minutos (conexão lenta)');
                        }
                    } else if (responseTime > 3000) {
                        connectionQuality = 'Média';
                        recommendations.push('Conexão aceitável para uso móvel');
                    } else {
                        connectionQuality = 'Boa';
                        recommendations.push('Conexão ideal para atualizações frequentes');
                    }
                    
                    showWarning(`✅ Conectividade: ${connectionQuality} (${responseTime}ms) - ${recommendations[0] || 'OK'}`);
                    
                    // Teste 4: Tentar API da CoinGecko
                    showWarning('🔄 Testando API CoinGecko...');
                    const coingeckoResponse = await makeRequest(`${COINGECKO_API_BASE}/ping`);
                    if (coingeckoResponse.ok) {
                        showWarning('✅ API CoinGecko acessível');
                        
                        // Teste 5: Tentar carregar dados completos
                        showWarning('🔄 Tentando carregar dados completos...');
                        setTimeout(() => {
                            loadCryptoData();
                        }, 1000);
                    } else {
                        showWarning('⚠️ API CoinGecko não acessível');
                        
                        // Tentar estratégia alternativa
                        showWarning('🔄 Tentando estratégia alternativa...');
                        setTimeout(() => {
                            loadCryptoData();
                        }, 1000);
                    }
                } else {
                    showWarning('❌ Problema de conectividade básica');
                }
                
            } catch (error) {
                console.error('Erro no teste de conectividade:', error);
                showWarning(`❌ Erro no teste de conectividade: ${error.message}`);
                
                // Tentar carregar dados mesmo com erro
                showWarning('🔄 Tentando carregar dados com fallback...');
                setTimeout(() => {
                    loadCryptoData();
                }, 1000);
            }
        }
        

        
        // Função para limpar cache e tentar novamente
        function clearCacheAndRetry() {
            try {
                // Limpar localStorage
                if (supportsLocalStorage()) {
                    localStorage.removeItem('cryptoCache');
                    console.log('🗑️ Cache localStorage limpo');
                }
                
                // Limpar cache em memória
                if (window.memoryCache) {
                    delete window.memoryCache;
                    console.log('🗑️ Cache em memória limpo');
                }
                
                // Resetar contadores
                retryCount = 0;
                lastUpdate = 0;
                
                showWarning('🔄 Cache limpo! Tentando carregar dados novamente...');
                
                // Tentar carregar dados novamente
                setTimeout(() => {
                    loadCryptoData();
                }, 1000);
                
            } catch (error) {
                console.error('Erro ao limpar cache:', error);
                showWarning('❌ Erro ao limpar cache');
            }
        }
        
        // Expor função globalmente
        window.clearCacheAndRetry = clearCacheAndRetry;
        
        // Função para debug detalhado da conectividade
        function debugConnectivity() {
            console.log('🔍 === DEBUG DE CONECTIVIDADE ===');
            console.log('📱 Dispositivo móvel:', isMobile);
            console.log('📡 Dados móveis:', isMobileData);
            console.log('🔌 API sendo usada:', isMobileData ? 'Binance API' : 'CoinGecko API');
            console.log('⏱️ Intervalo de atualização:', isMobileData ? '5 minutos' : '30 segundos');
            console.log('🌐 Online:', navigator.onLine);
            console.log('⏱️ Última atualização:', new Date(lastUpdate).toLocaleString());
            console.log('🔄 Tentativas:', retryCount);
            console.log('💾 Dados em cache:', cryptoData.length);
            
            if ('connection' in navigator) {
                const connection = navigator.connection;
                console.log('📶 Tipo de conexão:', connection.type);
                console.log('⚡ Velocidade efetiva:', connection.effectiveType);
                console.log('📊 Downlink:', connection.downlink, 'Mbps');
                console.log('📈 RTT:', connection.rtt, 'ms');
                console.log('🔋 Economia de dados:', connection.saveData);
            }
            
            // Informações específicas da API da Binance
            if (isMobileData) {
                console.log('🔌 === INFO DA API DA BINANCE ===');
                console.log('🌐 URL da API:', BINANCE_API_BASE);
                console.log('⏱️ Timeout configurado: 15 segundos');
                console.log('📊 Endpoint sendo usado: /ticker/24hr');
                console.log('💱 Filtro aplicado: Pares USDT');
                console.log('📈 Dados convertidos para formato CoinGecko');
                console.log('🔄 Fallback para CoinGecko se falhar');
            }
            
            console.log('💾 localStorage disponível:', supportsLocalStorage());
            console.log('🌐 Fetch disponível:', supportsFetch());
            console.log('================================');
            
            // Mostrar aviso para o usuário
            if (isMobileData) {
                showWarning('🔍 Debug completo executado! Verifique o console para detalhes da API da Binance.');
            } else {
                showWarning('🔍 Debug completo executado! Verifique o console para detalhes.');
            }
        }
        
        // Expor função de debug globalmente
        window.debugConnectivity = debugConnectivity;
        
        // Função para alternar favoritos
        function toggleFavorite(cryptoId) {
            const star = event.target;
            star.classList.toggle('active');
            
            // Salvar no localStorage
            let favorites = JSON.parse(localStorage.getItem('cryptoFavorites') || '[]');
            if (star.classList.contains('active')) {
                if (!favorites.includes(cryptoId)) {
                    favorites.push(cryptoId);
                }
            } else {
                favorites = favorites.filter(id => id !== cryptoId);
            }
            localStorage.setItem('cryptoFavorites', JSON.stringify(favorites));
            
            // Mostrar feedback visual
            if (star.classList.contains('active')) {
                showWarning('⭐ Adicionado aos favoritos!');
            } else {
                showWarning('💔 Removido dos favoritos');
            }
        }
        
        // Função para carregar favoritos salvos
        function loadFavorites() {
            const favorites = JSON.parse(localStorage.getItem('cryptoFavorites') || '[]');
            favorites.forEach(cryptoId => {
                const star = document.querySelector(`[onclick*="${cryptoId}"] .favorite-star`);
                if (star) {
                    star.classList.add('active');
                }
            });
        }
        
        // Função para buscar dados da API da Binance (otimizada para mobile)
        async function loadCryptoDataFromBinance() {
            try {
                console.log('🔄 Carregando dados da API da Binance para mobile...');
                console.log('📱 Status da conexão:', navigator.onLine ? 'Online' : 'Offline');
                console.log('📱 Tipo de conexão:', navigator.connection ? navigator.connection.effectiveType : 'Desconhecido');
                
                if (!navigator.onLine) { 
                    throw new Error('Dispositivo offline'); 
                }

                // Detectar conexão lenta
                const connection = navigator.connection;
                const isSlowConnection = connection && (
                    connection.effectiveType === 'slow-2g' || 
                    connection.effectiveType === '2g' || 
                    connection.effectiveType === '3g'
                );

                // ESTRATÉGIA DE EMERGÊNCIA: Timeouts muito mais agressivos para iPhone
                let timeout;
                if (isSlowConnection) {
                    timeout = 120000; // 2 MINUTOS para conexões muito lentas
                } else if (connection && connection.effectiveType === '4g') {
                    timeout = 90000; // 1.5 MINUTOS para 4G
                } else {
                    timeout = 60000; // 1 MINUTO para conexões normais
                }
                console.log(`🚨 ESTRATÉGIA DE EMERGÊNCIA: Timeout configurado: ${timeout/1000}s (${isSlowConnection ? 'Conexão muito lenta' : connection?.effectiveType || 'Normal'})`);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.log('⏰ Timeout atingido, abortando requisição...');
                    controller.abort();
                }, timeout);

                // Tentar múltiplas vezes com backoff exponencial
                let lastError;
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        console.log(`🔄 Tentativa ${attempt}/3 para conectar com Binance...`);
                        
                        const startTime = Date.now();
                        const response = await fetch(`${BINANCE_API_BASE}/ticker/24hr`, {
                            method: 'GET',
                            signal: controller.signal,
                            headers: { 
                                'Accept': 'application/json',
                                'Content-Type': 'application/json',
                                'Cache-Control': 'no-cache'
                            },
                            // Configurações específicas para conexões móveis
                            mode: 'cors',
                            credentials: 'omit'
                        });
                        
                        const endTime = Date.now();
                        const responseTime = endTime - startTime;
                        
                        clearTimeout(timeoutId);
                        console.log(`📡 Resposta da Binance recebida em ${responseTime}ms:`, response.status, response.statusText);
                        
                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('❌ Erro na resposta da Binance:', errorText);
                            throw new Error(`Erro na API da Binance: ${response.status} - ${errorText}`);
                        }

                        const binanceData = await response.json();
                        console.log('📊 Dados brutos da Binance recebidos:', binanceData.length, 'pares');
                        
                        if (!Array.isArray(binanceData) || binanceData.length === 0) {
                            throw new Error('Dados inválidos recebidos da Binance');
                        }

                        const usdtPairs = binanceData.filter(item => 
                            item.symbol && 
                            item.symbol.endsWith('USDT') && 
                            item.lastPrice && 
                            item.lastPrice !== '0'
                        );
                        
                        console.log('💱 Pares USDT válidos encontrados:', usdtPairs.length);
                        
                        if (usdtPairs.length === 0) {
                            throw new Error('Nenhum par USDT válido encontrado na Binance');
                        }

                        const convertedData = usdtPairs
                            .slice(0, 100)
                            .map(item => {
                                try {
                                    const price = parseFloat(item.lastPrice);
                                    const change = parseFloat(item.priceChangePercent);
                                    const volume = parseFloat(item.volume);
                                    const quoteVolume = parseFloat(item.quoteVolume);
                                    
                                    if (isNaN(price) || isNaN(change) || isNaN(volume)) {
                                        console.warn('⚠️ Dados inválidos ignorados:', item.symbol, item);
                                        return null;
                                    }

                                    return {
                                        id: item.symbol.toLowerCase().replace('usdt', ''),
                                        symbol: item.symbol.replace('USDT', ''),
                                        name: item.symbol.replace('USDT', ''),
                                        current_price: price,
                                        price_change_percentage_24h: change,
                                        total_volume: volume,
                                        quote_volume: quoteVolume,
                                        market_cap: quoteVolume, // Usar volume em USDT como aproximação
                                        market_cap_rank: 0,
                                        sparkline_in_7d: { price: [] },
                                        last_updated: new Date().toISOString()
                                    };
                                } catch (conversionError) {
                                    console.warn('⚠️ Erro ao converter item:', item.symbol, conversionError);
                                    return null;
                                }
                            })
                            .filter(item => item !== null);

                        if (convertedData.length === 0) {
                            throw new Error('Falha ao converter dados da Binance');
                        }

                        console.log(`✅ Dados convertidos com sucesso: ${convertedData.length} criptomoedas`);
                        
                        // Ordenar por volume e adicionar ranking
                        convertedData.sort((a, b) => (b.total_volume || 0) - (a.total_volume || 0));
                        convertedData.forEach((item, index) => {
                            item.market_cap_rank = index + 1;
                        });

                        // Atualizar dados e interface
                        savePreviousPrices();
                        cryptoData = convertedData;
                        filteredData = [...cryptoData];
                        
                        await loadGlobalMarketDataFromBinance();
                        saveToCache(convertedData);
                        displayCryptoData();
                        
                        localStorage.setItem('currentMobileAPI', 'Binance');

                        console.log('🎉 Dados da Binance carregados com sucesso!');
                        
                        return true;
                        
                    } catch (attemptError) {
                        lastError = attemptError;
                        console.warn(`⚠️ Tentativa ${attempt} falhou:`, attemptError.message);
                        
                        if (attempt < 3) {
                            const delay = Math.pow(2, attempt) * 1000; // Backoff exponencial: 2s, 4s
                            console.log(`⏳ Aguardando ${delay}ms antes da próxima tentativa...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }

                // Se todas as tentativas falharam
                throw lastError || new Error('Todas as tentativas falharam');

            } catch (error) {
                console.error('❌ Erro detalhado ao carregar dados da Binance:', error);
                console.error('❌ Stack trace:', error.stack);
                
                let errorMessage = 'Erro na API da Binance';
                if (error.name === 'AbortError') {
                    errorMessage = 'Timeout na API da Binance (conexão muito lenta)';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'Falha na conexão com Binance (verifique sua conexão)';
                } else if (error.message.includes('CORS')) {
                    errorMessage = 'Erro de CORS na Binance';
                } else if (error.message.includes('Timeout')) {
                    errorMessage = 'Conexão muito lenta com Binance';
                } else {
                    errorMessage = `Erro na API da Binance: ${error.message}`;
                }
                
                showWarning(`❌ ${errorMessage}`);
                
                console.log('🔄 Tentando fallback para CoinMarketCap...');
                try {
                    const fallbackSuccess = await loadCryptoDataFromCoinMarketCap();
                    if (fallbackSuccess) { 
                        showWarning('✅ Fallback para CoinMarketCap funcionou'); 
                        return true; 
                    }
                } catch (fallbackError) { 
                    console.error('❌ Fallback para CoinMarketCap falhou:', fallbackError); 
                }
                
                console.log('🔄 Tentando fallback para CoinGecko...');
                try {
                    const fallbackSuccess = await loadCryptoData();
                    if (fallbackSuccess) {
                        showWarning('✅ Fallback para CoinGecko funcionou');
                        return true;
                    }
                } catch (fallbackError) {
                    console.error('❌ Fallback para CoinGecko também falhou:', fallbackError);
                }
                
                return false;
            }
        }
        
        // Função para carregar dados da API da CoinMarketCap (alternativa robusta para mobile)
        async function loadCryptoDataFromCoinMarketCap() {
            try {
                console.log('🔄 Carregando dados da API da CoinMarketCap para mobile...');
                if (!navigator.onLine) { 
                    throw new Error('Dispositivo offline'); 
                }
                
                const connection = navigator.connection;
                const isSlowConnection = connection && (
                    connection.effectiveType === 'slow-2g' || 
                    connection.effectiveType === '2g' || 
                    connection.effectiveType === '3g'
                );
                // ESTRATÉGIA DE EMERGÊNCIA: Timeouts muito mais agressivos para iPhone
                let timeout;
                if (isSlowConnection) {
                    timeout = 120000; // 2 MINUTOS para conexões muito lentas
                } else if (connection && connection.effectiveType === '4g') {
                    timeout = 90000; // 1.5 MINUTOS para 4G
                } else {
                    timeout = 60000; // 1 MINUTO para conexões normais
                }
                
                console.log(`🚨 ESTRATÉGIA DE EMERGÊNCIA: Timeout configurado: ${timeout/1000}s (${isSlowConnection ? 'Conexão muito lenta' : connection?.effectiveType || 'Normal'})`);
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.log('⏰ Timeout atingido, abortando requisição...');
                    controller.abort();
                }, timeout);
                
                let lastError;
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        console.log(`🔄 Tentativa ${attempt}/3 para conectar com CoinMarketCap...`);
                        const startTime = Date.now();
                        
                        const response = await fetch(`${COINMARKETCAP_API_BASE}/cryptocurrency/listings/latest?limit=100&convert=USD`, {
                            method: 'GET',
                            signal: controller.signal,
                            headers: { 
                                'Accept': 'application/json',
                                'X-CMC_PRO_API_KEY': COINMARKETCAP_API_KEY,
                                'Cache-Control': 'no-cache'
                            },
                            mode: 'cors',
                            credentials: 'omit'
                        });
                        
                        const endTime = Date.now();
                        const responseTime = endTime - startTime;
                        clearTimeout(timeoutId);
                        
                        console.log(`📡 Resposta da CoinMarketCap recebida em ${responseTime}ms:`, response.status, response.statusText);
                        
                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('❌ Erro na resposta da CoinMarketCap:', errorText);
                            throw new Error(`Erro na API da CoinMarketCap: ${response.status} - ${errorText}`);
                        }
                        
                        const cmcData = await response.json();
                        console.log('📊 Dados brutos da CoinMarketCap recebidos:', cmcData.data ? cmcData.data.length : 0, 'criptomoedas');
                        
                        if (!cmcData.data || !Array.isArray(cmcData.data) || cmcData.data.length === 0) { 
                            throw new Error('Dados inválidos recebidos da CoinMarketCap'); 
                        }
                        
                        const convertedData = cmcData.data.map(item => {
                            try {
                                const price = parseFloat(item.quote?.USD?.price || 0);
                                const change = parseFloat(item.quote?.USD?.percent_change_24h || 0);
                                const volume = parseFloat(item.quote?.USD?.volume_24h || 0);
                                const marketCap = parseFloat(item.quote?.USD?.market_cap || 0);
                                
                                if (isNaN(price) || price <= 0) {
                                    console.warn('⚠️ Dados inválidos ignorados:', item.symbol, item);
                                    return null;
                                }
                                
                                return {
                                    id: item.slug || item.symbol.toLowerCase(),
                                    symbol: item.symbol,
                                    name: item.name,
                                    current_price: price,
                                    price_change_percentage_24h: change,
                                    total_volume: volume,
                                    quote_volume: volume,
                                    market_cap: marketCap,
                                    market_cap_rank: item.cmc_rank || 0,
                                    sparkline_in_7d: { price: [] },
                                    last_updated: new Date().toISOString()
                                };
                            } catch (conversionError) {
                                console.warn('⚠️ Erro ao converter item:', item.symbol, conversionError);
                                return null;
                            }
                        }).filter(item => item !== null);
                        
                        if (convertedData.length === 0) { 
                            throw new Error('Falha ao converter dados da CoinMarketCap'); 
                        }
                        
                        console.log(`✅ Dados convertidos com sucesso: ${convertedData.length} criptomoedas`);
                        
                        // Ordenar por market cap
                        convertedData.sort((a, b) => (b.market_cap || 0) - (a.market_cap || 0));
                        
                        savePreviousPrices(); 
                        cryptoData = convertedData; 
                        filteredData = [...cryptoData];
                        
                        // Simular dados globais
                        await loadGlobalMarketDataFromCoinMarketCap();
                        
                        saveToCache(convertedData); 
                        displayCryptoData();
                        
                        localStorage.setItem('currentMobileAPI', 'CoinMarketCap');

                        console.log('🎉 Dados da CoinMarketCap carregados com sucesso!'); 
                        return true;
                        
                    } catch (attemptError) {
                        lastError = attemptError;
                        console.warn(`⚠️ Tentativa ${attempt} falhou:`, attemptError.message);
                        if (attempt < 3) {
                            const delay = Math.pow(2, attempt) * 1000; // Backoff exponencial: 2s, 4s
                            console.log(`⏳ Aguardando ${delay}ms antes da próxima tentativa...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }
                
                throw lastError || new Error('Todas as tentativas falharam');
                
            } catch (error) {
                console.error('❌ Erro detalhado ao carregar dados da CoinMarketCap:', error);
                console.error('❌ Stack trace:', error.stack);
                
                let errorMessage = 'Erro na API da CoinMarketCap';
                if (error.name === 'AbortError') { 
                    errorMessage = 'Timeout na API da CoinMarketCap (conexão muito lenta)'; 
                } else if (error.message.includes('Failed to fetch')) { 
                    errorMessage = 'Falha na conexão com CoinMarketCap (verifique sua conexão)'; 
                } else if (error.message.includes('CORS')) { 
                    errorMessage = 'Erro de CORS na CoinMarketCap'; 
                } else if (error.message.includes('Timeout') || error.message.includes('Timeout')) { 
                    errorMessage = 'Conexão muito lenta com CoinMarketCap'; 
                } else { 
                    errorMessage = `Erro na API da CoinMarketCap: ${error.message}`; 
                }
                
                showWarning(`❌ ${errorMessage}`);
                return false;
            }
        }
        
                // Função para carregar dados da CoinGecko como fallback (com chave API)
        async function loadCryptoDataFromCoinGecko() {
            try {
                console.log('🔄 Carregando dados da API da CoinGecko como fallback (com chave API)...');
                if (!navigator.onLine) { 
                    throw new Error('Dispositivo offline'); 
                }
                
                const connection = navigator.connection;
                const isSlowConnection = connection && (
                    connection.effectiveType === 'slow-2g' || 
                    connection.effectiveType === '2g' || 
                    connection.effectiveType === '3g'
                );
                // ESTRATÉGIA DE EMERGÊNCIA: Timeouts muito mais agressivos para iPhone
                let timeout;
                if (isSlowConnection) {
                    timeout = 120000; // 2 MINUTOS para conexões muito lentas
                } else if (connection && connection.effectiveType === '4g') {
                    timeout = 90000; // 1.5 MINUTOS para 4G
                } else {
                    timeout = 60000; // 1 MINUTO para conexões normais
                }
                 
                console.log(`🚨 ESTRATÉGIA DE EMERGÊNCIA: Timeout configurado: ${timeout/1000}s (${isSlowConnection ? 'Conexão muito lenta' : connection?.effectiveType || 'Normal'})`);
                 
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.log('⏰ Timeout atingido, abortando requisição...');
                    controller.abort();
                }, timeout);
                
                const startTime = Date.now();
                
                // Usar sua chave API do CoinGecko para melhor confiabilidade
                const COINGECKO_API_KEY = 'CG-QGmu3Fbqu6bCfsY2Ntrnq8rK';
                
                const response = await fetch(`${COINGECKO_API_BASE}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false&locale=en&x_cg_demo_api_key=${COINGECKO_API_KEY}`, {
                    method: 'GET',
                    signal: controller.signal,
                    headers: { 
                        'Accept': 'application/json',
                        'X-CG-Demo-API-Key': COINGECKO_API_KEY,
                        'Cache-Control': 'no-cache'
                    },
                    mode: 'cors',
                    credentials: 'omit'
                });
                
                const endTime = Date.now();
                const responseTime = endTime - startTime;
                clearTimeout(timeoutId);
                
                console.log(`📡 Resposta da CoinGecko recebida em ${responseTime}ms:`, response.status, response.statusText);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Erro na resposta da CoinGecko:', errorText);
                    throw new Error(`Erro na API da CoinGecko: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                if (!data || data.length === 0) {
                    throw new Error('Dados inválidos recebidos da CoinGecko');
                }
                
                console.log(`✅ Dados da CoinGecko recebidos: ${data.length} criptomoedas`);
                
                cryptoData = data;
                filteredData = [...cryptoData];
                saveToCache(data);
                displayCryptoData();
                
                // Carregar dados globais
                await loadGlobalMarketData();
                
                localStorage.setItem('currentMobileAPI', 'CoinGecko');
                

                console.log('🎉 Dados da CoinGecko carregados com sucesso usando chave API!');
                return true;
                
            } catch (error) {
                console.error('❌ Erro ao carregar dados da CoinGecko como fallback:', error);
                return false;
            }
        }
        
        // Função para carregar dados da API da CryptoCompare (mais robusta para iPhone)
        async function loadCryptoDataFromCryptoCompare() {
            try {
                console.log('🔄 Carregando dados da API da CryptoCompare para iPhone...');
                if (!navigator.onLine) { 
                    throw new Error('Dispositivo offline'); 
                }
                
                const connection = navigator.connection;
                const isSlowConnection = connection && (
                    connection.effectiveType === 'slow-2g' || 
                    connection.effectiveType === '2g' || 
                    connection.effectiveType === '3g'
                );
                
                // ESTRATÉGIA DE EMERGÊNCIA: Timeouts muito mais agressivos para iPhone
                let timeout;
                if (isSlowConnection) {
                    timeout = 120000; // 2 MINUTOS para conexões muito lentas
                } else if (connection && connection.effectiveType === '4g') {
                    timeout = 90000; // 1.5 MINUTOS para 4G
                } else {
                    timeout = 60000; // 1 MINUTO para conexões normais
                }
                
                console.log(`🚨 ESTRATÉGIA DE EMERGÊNCIA: Timeout configurado: ${timeout/1000}s (${isSlowConnection ? 'Conexão muito lenta' : connection?.effectiveType || 'Normal'})`);
                
                // ESTRATÉGIA DE EMERGÊNCIA: Usar XMLHttpRequest em vez de fetch para iPhone
                console.log('🚨 ESTRATÉGIA DE EMERGÊNCIA: Usando XMLHttpRequest para iPhone...');
                
                return new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    const timeoutId = setTimeout(() => {
                        console.log('⏰ Timeout de emergência atingido!');
                        xhr.abort();
                        reject(new Error('Timeout de emergência na API da CryptoCompare'));
                    }, timeout);
                    
                    xhr.open('GET', `${CRYPTOCOMPARE_API_BASE}/top/mktcapfull?limit=100&tsym=USD`, true);
                    xhr.setRequestHeader('Accept', 'application/json');
                    xhr.setRequestHeader('Cache-Control', 'no-cache');
                    
                    // Configurações específicas para iPhone
                    xhr.timeout = timeout;
                    xhr.withCredentials = false;
                    
                    xhr.onload = function() {
                        clearTimeout(timeoutId);
                        if (xhr.status === 200) {
                            try {
                                const ccData = JSON.parse(xhr.responseText);
                                console.log('📊 Dados brutos da CryptoCompare recebidos:', ccData.Data ? ccData.Data.length : 0, 'criptomoedas');
                                
                                if (!ccData.Data || !Array.isArray(ccData.Data) || ccData.Data.length === 0) { 
                                    reject(new Error('Dados inválidos recebidos da CryptoCompare')); 
                                    return;
                                }
                                
                                const convertedData = ccData.Data.map(item => {
                                    try {
                                        const raw = item.RAW?.USD;
                                        if (!raw) return null;
                                        
                                        const price = parseFloat(raw.PRICE || 0);
                                        const change = parseFloat(raw.CHANGEPCT24HOUR || 0);
                                        const volume = parseFloat(raw.VOLUME24HOUR || 0);
                                        const marketCap = parseFloat(raw.MKTCAP || 0);
                                        
                                        if (isNaN(price) || price <= 0) {
                                            console.warn('⚠️ Dados inválidos ignorados:', item.CoinInfo.Name, item);
                                            return null;
                                        }
                                        
                                        return {
                                            id: item.CoinInfo.Name.toLowerCase(),
                                            symbol: item.CoinInfo.Name,
                                            name: item.CoinInfo.FullName,
                                            current_price: price,
                                            price_change_percentage_24h: change,
                                            total_volume: volume,
                                            quote_volume: volume,
                                            market_cap: marketCap,
                                            market_cap_rank: item.RAW.USD.RANK || 0,
                                            sparkline_in_7d: { price: [] },
                                            last_updated: new Date().toISOString()
                                        };
                                    } catch (conversionError) {
                                        console.warn('⚠️ Erro ao converter item:', item.CoinInfo.Name, conversionError);
                                        return null;
                                    }
                                }).filter(item => item !== null);
                                
                                if (convertedData.length === 0) { 
                                    reject(new Error('Falha ao converter dados da CryptoCompare')); 
                                    return;
                                }
                                
                                console.log(`✅ Dados convertidos com sucesso: ${convertedData.length} criptomoedas`);
                                
                                // Ordenar por market cap
                                convertedData.sort((a, b) => (b.market_cap || 0) - (a.market_cap || 0));
                                
                                savePreviousPrices(); 
                                cryptoData = convertedData; 
                                filteredData = [...cryptoData];
                                
                                // Simular dados globais
                                loadGlobalMarketDataFromCryptoCompare();
                                
                                saveToCache(convertedData); 
                                displayCryptoData();
                                
                                localStorage.setItem('currentMobileAPI', 'CryptoCompare');
        
        
                                console.log('🎉 Dados da CryptoCompare carregados com sucesso usando estratégia de emergência!'); 
                                resolve(true);
                                
                            } catch (parseError) {
                                reject(new Error(`Erro ao processar resposta: ${parseError.message}`));
                            }
                        } else {
                            reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
                        }
                    };
                    
                    xhr.onerror = function() {
                        clearTimeout(timeoutId);
                        reject(new Error('Erro de rede na requisição XMLHttpRequest'));
                    };
                    
                    xhr.ontimeout = function() {
                        clearTimeout(timeoutId);
                        reject(new Error('Timeout na requisição XMLHttpRequest'));
                    };
                    
                    xhr.onabort = function() {
                        clearTimeout(timeoutId);
                        reject(new Error('Requisição abortada'));
                    };
                    
                    console.log('📡 Enviando requisição XMLHttpRequest para CryptoCompare...');
                    xhr.send();
                });
                
            } catch (error) {
                console.error('❌ Erro detalhado ao carregar dados da CryptoCompare:', error);
                console.error('❌ Stack trace:', error.stack);
                
                let errorMessage = 'Erro na API da CryptoCompare';
                if (error.message.includes('Timeout de emergência')) { 
                    errorMessage = 'Timeout de emergência na API da CryptoCompare (conexão extremamente lenta)'; 
                } else if (error.message.includes('Failed to fetch')) { 
                    errorMessage = 'Falha na conexão com CryptoCompare (verifique sua conexão)'; 
                } else if (error.message.includes('CORS')) { 
                    errorMessage = 'Erro de CORS na CryptoCompare'; 
                } else if (error.message.includes('Timeout')) { 
                    errorMessage = 'Conexão muito lenta com CryptoCompare'; 
                } else { 
                    errorMessage = `Erro na API da CryptoCompare: ${error.message}`; 
                }
                
                showWarning(`❌ ${errorMessage}`);
                return false;
            }
        }
        
        // Função para carregar dados globais do mercado da CryptoCompare
        async function loadGlobalMarketDataFromCryptoCompare() {
            try {
                console.log('🔄 Carregando dados globais do mercado da CryptoCompare...');
                
                // Simular dados globais baseados nos dados das criptomoedas
                const totalMarketCap = cryptoData.reduce((sum, crypto) => sum + (crypto.market_cap || 0), 0);
                const totalVolume = cryptoData.reduce((sum, crypto) => sum + (crypto.total_volume || 0), 0);
                const marketCapChange = cryptoData.reduce((sum, crypto) => sum + (crypto.price_change_percentage_24h || 0), 0) / cryptoData.length;
                
                globalMarketData = {
                    total_market_cap: { usd: totalMarketCap },
                    total_volume: { usd: totalVolume },
                    market_cap_change_percentage_24h: marketCapChange,
                    market_cap_change_24h_usd: totalMarketCap * (marketCapChange / 100),
                    last_updated: new Date().toISOString()
                };
                
                console.log('✅ Dados globais da CryptoCompare carregados:', globalMarketData);
                
            } catch (error) {
                console.error('❌ Erro ao carregar dados globais da CryptoCompare:', error);
                // Usar dados padrão se falhar
                globalMarketData = {
                    total_market_cap: { usd: 0 },
                    total_volume: { usd: 0 },
                    market_cap_change_percentage_24h: 0,
                    market_cap_change_24h_usd: 0,
                    last_updated: new Date().toISOString()
                };
            }
        }
        
        // Função para carregar dados globais do mercado da Binance
        async function loadGlobalMarketDataFromBinance() {
            try {
                // Buscar estatísticas globais da Binance
                const response = await makeRequest(`${BINANCE_API_BASE}/ticker/24hr`);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Calcular estatísticas globais
                    let totalMarketCap = 0;
                    let totalVolume = 0;
                    let totalChange24h = 0;
                    let activeCoins = 0;
                    
                    data.forEach(item => {
                        if (item.symbol.endsWith('USDT')) {
                            const price = parseFloat(item.lastPrice);
                            const volume = parseFloat(item.quoteVolume);
                            const change = parseFloat(item.priceChangePercent);
                            
                            totalMarketCap += volume; // Aproximação
                            totalVolume += volume;
                            totalChange24h += change;
                            activeCoins++;
                        }
                    });
                    
                    // Atualizar dados globais
                    globalMarketData = {
                        total_market_cap: { usd: totalMarketCap },
                        total_volume: { usd: totalVolume },
                        market_cap_percentage: { usd: totalChange24h / activeCoins },
                        market_cap_change_percentage_24h_usd: totalChange24h / activeCoins
                    };
                    
                    console.log('✅ Dados globais da Binance carregados');
                }
            } catch (error) {
                console.error('❌ Erro ao carregar dados globais da Binance:', error);
            }
        }
        
        // Função para carregar dados globais do mercado da CoinMarketCap
        async function loadGlobalMarketDataFromCoinMarketCap() {
            try {
                console.log('🔄 Carregando dados globais do mercado da CoinMarketCap...');
                
                // Simular dados globais baseados nos dados das criptomoedas
                const totalMarketCap = cryptoData.reduce((sum, crypto) => sum + (crypto.market_cap || 0), 0);
                const totalVolume = cryptoData.reduce((sum, crypto) => sum + (crypto.total_volume || 0), 0);
                const marketCapChange = cryptoData.reduce((sum, crypto) => sum + (crypto.price_change_percentage_24h || 0), 0) / cryptoData.length;
                
                globalMarketData = {
                    total_market_cap: { usd: totalMarketCap },
                    total_volume: { usd: totalVolume },
                    market_cap_change_percentage_24h: marketCapChange,
                    market_cap_change_24h_usd: totalMarketCap * (marketCapChange / 100),
                    last_updated: new Date().toISOString()
                };
                
                console.log('✅ Dados globais da CoinMarketCap carregados:', globalMarketData);
                
            } catch (error) {
                console.error('❌ Erro ao carregar dados globais da CoinMarketCap:', error);
                // Usar dados padrão se falhar
                globalMarketData = {
                    total_market_cap: { usd: 0 },
                    total_volume: { usd: 0 },
                    market_cap_change_percentage_24h: 0,
                    market_cap_change_24h_usd: 0,
                    last_updated: new Date().toISOString()
                };
            }
        }

        // Função para testar especificamente a API da CoinMarketCap
        async function testCoinMarketCapAPI() {
            try {
                console.log('🧪 === TESTE ESPECÍFICO DA API DA COINMARKETCAP ===');
                showWarning('🧪 Testando API da CoinMarketCap...');
                
                // Teste 1: Verificar conectividade
                console.log('📡 Teste 1: Verificando conectividade...');
                if (!navigator.onLine) { 
                    throw new Error('Dispositivo offline'); 
                }
                
                // Teste 2: Verificar qualidade da conexão
                const connection = navigator.connection;
                if (connection) {
                    console.log('📱 Tipo de conexão:', connection.effectiveType);
                    console.log('📶 RTT estimado:', connection.rtt, 'ms');
                    console.log('📊 Largura de banda:', connection.downlink, 'Mbps');
                    console.log('🔋 Economia de dados:', connection.saveData);
                }
                
                // Teste 3: Teste principal com timeout adaptativo
                console.log('⏱️ Teste 3: Testando endpoint principal...');
                const isSlowConnection = connection && (
                    connection.effectiveType === 'slow-2g' || 
                    connection.effectiveType === '2g' || 
                    connection.effectiveType === '3g'
                );
                const timeout = isSlowConnection ? 30000 : 20000;
                
                console.log(`⏱️ Timeout configurado: ${timeout}ms (${isSlowConnection ? 'Conexão lenta' : 'Conexão normal'})`);
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.log('⏰ Timeout atingido!');
                    controller.abort();
                }, timeout);
                
                const startTime = Date.now();
                const response = await fetch(`${COINMARKETCAP_API_BASE}/cryptocurrency/listings/latest?limit=10&convert=USD`, {
                    method: 'GET',
                    signal: controller.signal,
                    headers: { 
                        'Accept': 'application/json',
                        'X-CMC_PRO_API_KEY': COINMARKETCAP_API_KEY,
                        'Cache-Control': 'no-cache'
                    },
                    mode: 'cors',
                    credentials: 'omit'
                });
                
                const endTime = Date.now();
                const responseTime = endTime - startTime;
                clearTimeout(timeoutId);
                
                console.log(`📊 Tempo de resposta total: ${responseTime}ms`);
                console.log(`📡 Status da resposta: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log(`✅ Dados recebidos: ${data.data ? data.data.length : 0} criptomoedas`);
                
                console.log('🔍 Teste 4: Validando dados...');
                if (data.data && data.data.length > 0) {
                    const sample = data.data[0];
                    console.log('📋 Exemplo de dados:', { 
                        symbol: sample.symbol, 
                        name: sample.name,
                        price: sample.quote?.USD?.price, 
                        change: sample.quote?.USD?.percent_change_24h 
                    });
                }
                
                let performanceRating = 'Excelente';
                if (responseTime > 15000) performanceRating = 'Lenta';
                else if (responseTime > 8000) performanceRating = 'Média';
                else if (responseTime > 4000) performanceRating = 'Boa';
                
                console.log(`📈 Performance: ${performanceRating} (${responseTime}ms)`);
                showWarning(`✅ API da CoinMarketCap funcionando! Tempo: ${responseTime}ms, Criptomoedas: ${data.data ? data.data.length : 0}, Performance: ${performanceRating}`);
                return true;
                
            } catch (error) {
                console.error('❌ Erro no teste da CoinMarketCap:', error);
                
                let errorMsg = 'Erro na API da CoinMarketCap';
                if (error.name === 'AbortError') {
                    errorMsg = 'Timeout na API da CoinMarketCap (conexão muito lenta)';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMsg = 'Falha na conexão com CoinMarketCap (verifique sua conexão)';
                } else if (error.message.includes('CORS')) {
                    errorMsg = 'Erro de CORS na CoinMarketCap';
                } else if (error.message.includes('HTTP')) {
                    errorMsg = `Erro HTTP: ${error.message}`;
                } else if (error.message.includes('Timeout')) {
                    errorMsg = 'Conexão muito lenta com CoinMarketCap';
                } else {
                    errorMsg = `Erro: ${error.message}`;
                }
                
                showWarning(`❌ ${errorMsg}`);
                
                if (error.name === 'AbortError') {
                    console.log('💡 Sugestão: Sua conexão está muito lenta. Tente:');
                    console.log('   - Verificar se está em área com boa cobertura');
                    console.log('   - Desativar economia de dados no celular');
                    console.log('   - Tentar em horário de menor tráfego');
                } else if (error.message.includes('Failed to fetch')) {
                    console.log('💡 Sugestões: Problema de conectividade. Tente:');
                    console.log('   - Verificar se o celular está online');
                    console.log('   - Testar em WiFi primeiro');
                    console.log('   - Verificar configurações de rede');
                }
                
                return false;
            }
        }
        

        
        // Função para testar especificamente a API da CryptoCompare (mais robusta para iPhone)
        async function testCryptoCompareAPI() {
            try {
                console.log('🧪 === TESTE ESPECÍFICO DA API DA CRYPTOCOMPARE (IPHONE) ===');
                showWarning('🧪 Testando API da CryptoCompare para iPhone...');
                
                // Teste 1: Verificar conectividade
                console.log('📡 Teste 1: Verificando conectividade...');
                if (!navigator.onLine) { 
                    throw new Error('Dispositivo offline'); 
                }
                
                // Teste 2: Verificar qualidade da conexão
                const connection = navigator.connection;
                if (connection) {
                    console.log('📱 Tipo de conexão:', connection.effectiveType);
                    console.log('📶 RTT estimado:', connection.rtt, 'ms');
                    console.log('📊 Largura de banda:', connection.downlink, 'Mbps');
                    console.log('🔋 Economia de dados:', connection.saveData);
                }
                
                // Teste 3: Teste de ping simples
                console.log('🏓 Teste 3: Testando ping para CryptoCompare...');
                const pingStart = Date.now();
                try {
                    const pingResponse = await fetch(`${CRYPTOCOMPARE_API_BASE}/ping`, {
                        method: 'GET',
                        signal: AbortSignal.timeout(15000) // 15s para ping
                    });
                    const pingEnd = Date.now();
                    const pingTime = pingEnd - pingStart;
                    console.log(`🏓 Ping para CryptoCompare: ${pingTime}ms`);
                    
                    if (pingTime > 8000) {
                        console.warn('⚠️ Ping muito alto - conexão pode estar lenta');
                    }
                } catch (pingError) {
                    console.warn('⚠️ Ping falhou, mas continuando com teste principal...');
                }
                
                // Teste 4: Teste principal com timeout adaptativo
                console.log('⏱️ Teste 4: Testando endpoint principal...');
                const isSlowConnection = connection && (
                    connection.effectiveType === 'slow-2g' || 
                    connection.effectiveType === '2g' || 
                    connection.effectiveType === '3g'
                );
                const timeout = isSlowConnection ? 35000 : 25000; // Timeouts mais generosos para iPhone
                
                console.log(`⏱️ Timeout configurado: ${timeout}ms (${isSlowConnection ? 'Conexão lenta' : 'Conexão normal'})`);
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.log('⏰ Timeout atingido!');
                    controller.abort();
                }, timeout);
                
                const startTime = Date.now();
                const response = await fetch(`${CRYPTOCOMPARE_API_BASE}/top/mktcapfull?limit=10&tsym=USD`, {
                    method: 'GET',
                    signal: controller.signal,
                    headers: { 
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    },
                    mode: 'cors',
                    credentials: 'omit'
                });
                
                const endTime = Date.now();
                const responseTime = endTime - startTime;
                clearTimeout(timeoutId);
                
                console.log(`📊 Tempo de resposta total: ${responseTime}ms`);
                console.log(`📡 Status da resposta: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log(`✅ Dados recebidos: ${data.Data ? data.Data.length : 0} criptomoedas`);
                
                console.log('🔍 Teste 5: Validando dados...');
                if (data.Data && data.Data.length > 0) {
                    const sample = data.Data[0];
                    console.log('📋 Exemplo de dados:', { 
                        symbol: sample.CoinInfo?.Name, 
                        name: sample.CoinInfo?.FullName,
                        price: sample.RAW?.USD?.PRICE, 
                        change: sample.RAW?.USD?.CHANGEPCT24HOUR 
                    });
                }
                
                let performanceRating = 'Excelente';
                if (responseTime > 20000) performanceRating = 'Lenta';
                else if (responseTime > 12000) performanceRating = 'Média';
                else if (responseTime > 8000) performanceRating = 'Boa';
                
                console.log(`📈 Performance: ${performanceRating} (${responseTime}ms)`);
                showWarning(`✅ API da CryptoCompare funcionando! Tempo: ${responseTime}ms, Criptomoedas: ${data.Data ? data.Data.length : 0}, Performance: ${performanceRating}`);
                
                console.log('🎯 Esta API é especialmente otimizada para iPhone e deve funcionar melhor que as outras!');
                return true;
                
            } catch (error) {
                console.error('❌ Erro no teste da CryptoCompare:', error);
                
                let errorMsg = 'Erro na API da CryptoCompare';
                if (error.name === 'AbortError') {
                    errorMsg = 'Timeout na API da CryptoCompare (conexão muito lenta)';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMsg = 'Falha na conexão com CryptoCompare (verifique sua conexão)';
                } else if (error.message.includes('CORS')) {
                    errorMsg = 'Erro de CORS na CryptoCompare';
                } else if (error.message.includes('HTTP')) {
                    errorMsg = `Erro HTTP: ${error.message}`;
                } else if (error.message.includes('Timeout')) {
                    errorMsg = 'Conexão muito lenta com CryptoCompare';
                } else {
                    errorMsg = `Erro: ${error.message}`;
                }
                
                showWarning(`❌ ${errorMsg}`);
                
                if (error.name === 'AbortError') {
                    console.log('💡 Sugestão para iPhone: Sua conexão está muito lenta. Tente:');
                    console.log('   - Verificar se está em área com boa cobertura 4G/5G');
                    console.log('   - Desativar economia de dados no iPhone');
                    console.log('   - Tentar em horário de menor tráfego');
                    console.log('   - Verificar configurações de rede do iPhone');
                } else if (error.message.includes('Failed to fetch')) {
                    console.log('💡 Sugestões para iPhone: Problema de conectividade. Tente:');
                    console.log('   - Verificar se o iPhone está online');
                    console.log('   - Testar em WiFi primeiro');
                    console.log('   - Verificar configurações de rede do iPhone');
                    console.log('   - Tentar em modo avião e desativar');
                }
                
                return false;
            }
        }
        
        // Função para testar especificamente a API da Binance
        async function testBinanceAPI() {
            try {
                console.log('🧪 === TESTE ESPECÍFICO DA API DA BINANCE ===');
                showWarning('🧪 Testando API da Binance...');
                
                // Teste 1: Verificar conectividade
                console.log('📡 Teste 1: Verificando conectividade...');
                if (!navigator.onLine) { 
                    throw new Error('Dispositivo offline'); 
                }
                
                // Teste 2: Verificar qualidade da conexão
                const connection = navigator.connection;
                if (connection) {
                    console.log('📱 Tipo de conexão:', connection.effectiveType);
                    console.log('📶 RTT estimado:', connection.rtt, 'ms');
                    console.log('📊 Largura de banda:', connection.downlink, 'Mbps');
                    console.log('🔋 Economia de dados:', connection.saveData);
                }
                
                // Teste 3: Teste de ping simples
                console.log('🏓 Teste 3: Testando ping para Binance...');
                const pingStart = Date.now();
                try {
                    const pingResponse = await fetch(`${BINANCE_API_BASE}/ping`, {
                        method: 'GET',
                        signal: AbortSignal.timeout(10000) // 10s para ping
                    });
                    const pingEnd = Date.now();
                    const pingTime = pingEnd - pingStart;
                    console.log(`🏓 Ping para Binance: ${pingTime}ms`);
                    
                    if (pingTime > 5000) {
                        console.warn('⚠️ Ping muito alto - conexão pode estar lenta');
                    }
                } catch (pingError) {
                    console.warn('⚠️ Ping falhou, mas continuando com teste principal...');
                }
                
                // Teste 4: Teste principal com timeout adaptativo
                console.log('⏱️ Teste 4: Testando endpoint principal...');
                const isSlowConnection = connection && (
                    connection.effectiveType === 'slow-2g' || 
                    connection.effectiveType === '2g' || 
                    connection.effectiveType === '3g'
                );
                const timeout = isSlowConnection ? 25000 : 15000;
                
                console.log(`⏱️ Timeout configurado: ${timeout}ms (${isSlowConnection ? 'Conexão lenta' : 'Conexão normal'})`);
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.log('⏰ Timeout atingido!');
                    controller.abort();
                }, timeout);
                
                const startTime = Date.now();
                const response = await fetch(`${BINANCE_API_BASE}/ticker/24hr`, {
                    method: 'GET',
                    signal: controller.signal,
                    headers: { 
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    },
                    mode: 'cors',
                    credentials: 'omit'
                });
                
                const endTime = Date.now();
                const responseTime = endTime - startTime;
                
                clearTimeout(timeoutId);
                
                console.log(`📊 Tempo de resposta total: ${responseTime}ms`);
                console.log(`📡 Status da resposta: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log(`✅ Dados recebidos: ${data.length} pares`);
                
                // Teste 5: Validar dados
                console.log('🔍 Teste 5: Validando dados...');
                const usdtPairs = data.filter(item => 
                    item.symbol && 
                    item.symbol.endsWith('USDT') && 
                    item.lastPrice && 
                    item.lastPrice !== '0'
                );
                
                console.log(`💱 Pares USDT válidos: ${usdtPairs.length}`);
                
                if (usdtPairs.length > 0) {
                    const sample = usdtPairs[0];
                    console.log('📋 Exemplo de dados:', {
                        symbol: sample.symbol,
                        price: sample.lastPrice,
                        change: sample.priceChangePercent,
                        volume: sample.volume
                    });
                }
                
                // Análise de performance
                let performanceRating = 'Excelente';
                if (responseTime > 10000) performanceRating = 'Lenta';
                else if (responseTime > 5000) performanceRating = 'Média';
                else if (responseTime > 2000) performanceRating = 'Boa';
                
                console.log(`📈 Performance: ${performanceRating} (${responseTime}ms)`);
                
                showWarning(`✅ API da Binance funcionando! Tempo: ${responseTime}ms, Pares: ${usdtPairs.length}, Performance: ${performanceRating}`);
                return true;
                
            } catch (error) {
                console.error('❌ Erro no teste da Binance:', error);
                
                let errorMsg = 'Erro na API da Binance';
                if (error.name === 'AbortError') {
                    errorMsg = 'Timeout na API da Binance (conexão muito lenta)';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMsg = 'Falha na conexão com Binance (verifique sua conexão)';
                } else if (error.message.includes('CORS')) {
                    errorMsg = 'Erro de CORS na Binance';
                } else if (error.message.includes('HTTP')) {
                    errorMsg = `Erro HTTP: ${error.message}`;
                } else if (error.message.includes('Timeout')) {
                    errorMsg = 'Conexão muito lenta com Binance';
                } else {
                    errorMsg = `Erro: ${error.message}`;
                }
                
                showWarning(`❌ ${errorMsg}`);
                
                // Sugestões baseadas no erro
                if (error.name === 'AbortError') {
                    console.log('💡 Sugestão: Sua conexão está muito lenta. Tente:');
                    console.log('   - Verificar se está em área com boa cobertura');
                    console.log('   - Desativar economia de dados no celular');
                    console.log('   - Tentar em horário de menor tráfego');
                } else if (error.message.includes('Failed to fetch')) {
                    console.log('💡 Sugestões: Problema de conectividade. Tente:');
                    console.log('   - Verificar se o celular está online');
                    console.log('   - Testar em WiFi primeiro');
                    console.log('   - Verificar configurações de rede');
                }
                
                return false;
            }
        }
        </script>
</body>
</html>
